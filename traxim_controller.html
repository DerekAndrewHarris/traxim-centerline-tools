<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traxim Control Interface</title>
    <!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "100b3db215f04098972a2d1be37f3721"}'></script><!-- End Cloudflare Web Analytics -->
    <link rel="icon" type="image/png" href="traxim button - tight.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            min-height: 100vh;
            color: white;
            overflow: hidden;
        }

        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 0;
        }

        .header {
            background: rgba(0, 0, 0, 0.85);
            padding: 8px 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(67, 160, 71, 0.3);
            flex-shrink: 0;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .header-logo {
            height: 28px;
            flex-shrink: 0;
        }
        
        .header h1 {
            color: white;
            font-size: 1.4rem;
            margin: 0;
            font-weight: bold;
        }
        
        .header-user-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .user-email {
            color: #43a047;
            font-size: 12px;
            font-weight: bold;
        }
        
        .header-logout-btn {
            background: #e53935 !important;
            color: white !important;
            padding: 6px 14px !important;
            border: none !important;
            border-radius: 3px !important;
            font-size: 12px !important;
            font-weight: bold !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
        }
        
        .header-logout-btn:hover {
            background: #c62828 !important;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            flex: 1;
            overflow: hidden;
            padding: 8px;
        }

        .control-panel, .scenario-panel, .console-panel {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            padding: 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .control-panel h2, .scenario-panel h2, .console-panel h2 {
            color: white;
            margin-bottom: 8px;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .form-group {
            margin-bottom: 8px;
        }

        label {
            display: block;
            margin-bottom: 4px;
            color: white;
            font-weight: normal;
            font-size: 12px;
        }

        /* Checkbox alignment */
        label input[type="checkbox"] {
            width: auto;
            margin-right: 6px;
            vertical-align: middle;
            position: relative;
            top: -1px;
        }

        label:has(input[type="checkbox"]) {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
        }

        select, input, button {
            width: 100%;
            padding: 7px 10px;
            border: 1px solid #555;
            border-radius: 3px;
            font-size: 12px;
            transition: all 0.2s ease;
            background: #2a2a2a;
            color: white;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #43a047;
            box-shadow: 0 0 0 2px rgba(67, 160, 71, 0.2);
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-bottom: 8px;
        }

        .inline-input-group {
            display: flex;
            gap: 8px;
            align-items: stretch;
        }

        .inline-input-group select,
        .inline-input-group input {
            flex: 1;
            margin: 0;
        }
        
        .inline-input-group input:not(.browse-btn) {
            flex: 1 1 85%;
        }

        .inline-input-group button {
            flex: 1;
            margin: 0;
            height: auto;
            min-height: 32px;
            font-size: 11px;
            padding: 6px 10px;
            white-space: nowrap;
        }
        
        .browse-btn {
            background: #555 !important;
            color: white !important;
            font-size: 11px !important;
            padding: 5px 10px !important;
            width: 15% !important;
            min-width: 60px !important;
            max-width: 80px !important;
            flex: 0 0 15% !important;
            white-space: normal !important;
            word-wrap: break-word !important;
            line-height: 1.2 !important;
        }
        
        .browse-btn:hover {
            background: #666 !important;
        }
        
        .refresh-list-btn {
            flex: 0 0 auto !important;
            width: 80px !important;
            min-width: 80px !important;
            max-width: 80px !important;
            font-size: 11px !important;
            padding: 6px 10px !important;
            white-space: nowrap !important;
        }
        
        .full-width-select {
            width: 100% !important;
            margin-bottom: 8px;
        }
        
        .scenario-button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .dropdown-with-delete {
            display: flex;
            gap: 6px;
            align-items: stretch;
            margin-bottom: 8px;
        }
        
        .dropdown-with-button {
            flex: 1;
            margin: 0;
        }
        
        .delete-scenario-btn {
            background: #e53935 !important;
            color: white !important;
            border: 1px solid #e53935 !important;
            padding: 6px 12px !important;
            border-radius: 3px !important;
            font-size: 12px !important;
            font-weight: bold !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
            flex: 0 0 20%;
            max-width: 80px;
            min-width: 60px;
        }
        
        .delete-scenario-btn:hover:not(:disabled) {
            background: #c62828 !important;
            border-color: #c62828 !important;
        }
        
        .delete-scenario-btn:disabled {
            background: #555 !important;
            border-color: #555 !important;
            cursor: not-allowed !important;
            opacity: 0.65;
        }
        
        .new-scenario-btn {
            background: #555 !important;
            color: white !important;
            border: 1px solid #555 !important;
            padding: 9px 14px !important;
            border-radius: 3px !important;
            font-size: 12px !important;
            font-weight: bold !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
        }
        
        .new-scenario-btn:hover {
            background: #666 !important;
            border-color: #666 !important;
        }
        
        .save-btn {
            background: #43a047 !important;
            color: white !important;
            border: 1px solid #43a047 !important;
            padding: 9px 14px !important;
            border-radius: 3px !important;
            font-size: 12px !important;
            font-weight: bold !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
        }
        
        .save-btn:hover {
            background: #2e7d32 !important;
            border-color: #2e7d32 !important;
        }
        
        .half-width-input {
            width: 50% !important;
            flex: 0 0 50% !important;
        }
        
        .checkbox-with-input {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }
        
        .checkbox-with-input label {
            margin: 0;
            display: flex;
            align-items: center;
        }
        
        .form-group h4 {
            font-weight: normal;
            margin-bottom: 4px;
            font-size: 12px;
            color: #43a047;
        }

        button {
            background: #43a047;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        button:hover {
            background: #2e7d32;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
        }

        .status {
            padding: 9px;
            border-radius: 3px;
            margin-bottom: 8px;
            font-weight: bold;
            text-align: center;
            font-size: 12px;
        }

        .status.idle {
            background: rgba(67, 160, 71, 0.2);
            color: #66bb6a;
            border: 1px solid #43a047;
        }

        .status.running {
            background: rgba(255, 235, 59, 0.2);
            color: #fdd835;
            border: 1px solid #fbc02d;
        }

        .status.error {
            background: rgba(229, 57, 53, 0.2);
            color: #ef5350;
            border: 1px solid #e53935;
        }

        .status.success {
            background: rgba(67, 160, 71, 0.2);
            color: #66bb6a;
            border: 1px solid #43a047;
        }

        .output-area {
            background: #0a0a0a;
            color: #ccc;
            border-radius: 3px;
            padding: 12px;
            flex: 1;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.4;
            border: 1px solid #333;
        }

        .control-panel h3 {
            margin-top: 8px;
            margin-bottom: 8px;
            color: #66bb6a;
            font-size: 1.05rem;
            font-weight: bold;
        }

        .output-area::-webkit-scrollbar {
            width: 6px;
        }

        .output-area::-webkit-scrollbar-track {
            background: #0a0a0a;
        }

        .output-area::-webkit-scrollbar-thumb {
            background: #43a047;
            border-radius: 3px;
        }

        .output-line {
            margin-bottom: 3px;
            padding: 1px 0;
        }

        .output-line.timestamp {
            color: #43a047;
        }

        .output-line.error {
            color: #ef5350;
        }

        .output-line.info {
            color: #66bb6a;
        }

        .auto-schedule {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            padding: 10px;
            margin-top: 8px;
        }

        .auto-schedule h2 {
            color: #43a047;
            font-size: 1.1rem;
            margin-bottom: 8px;
        }

        .schedule-info {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 6px;
            margin-top: 6px;
        }

        .schedule-stat {
            text-align: center;
            padding: 6px;
            background: rgba(67, 160, 71, 0.1);
            border-radius: 3px;
            border: 1px solid rgba(67, 160, 71, 0.3);
        }

        .schedule-stat .value {
            display: block;
            font-size: 1.2rem;
            font-weight: bold;
            color: #43a047;
        }

        .schedule-stat .label {
            color: #ccc;
            font-size: 0.8rem;
            margin-top: 3px;
        }


        .scenario-section {
            margin-bottom: 12px;
            padding: 10px;
            background: rgba(67, 160, 71, 0.05);
            border-radius: 5px;
            border-left: 3px solid #43a047;
        }

        .scenario-section h3 {
            color: #66bb6a;
            margin-bottom: 8px;
            font-size: 1.05rem;
            font-weight: bold;
        }

        .inline-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .three-column-group {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }
        
        .single-row-checkboxes {
            display: grid;
            grid-template-columns: auto auto auto;
            gap: 12px;
            align-items: center;
        }
        
        .single-row-checkboxes label {
            margin-bottom: 0;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr 1fr;
            }
            
            .console-panel {
                grid-column: 1 / -1;
            }
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .schedule-info {
                grid-template-columns: 1fr;
            }
            
            .button-group, .inline-group {
                grid-template-columns: 1fr;
            }
        }
        
        /* Panel scrollbars */
        .scenario-panel::-webkit-scrollbar,
        .control-panel::-webkit-scrollbar,
        .console-panel::-webkit-scrollbar {
            width: 6px;
        }

        .scenario-panel::-webkit-scrollbar-track,
        .control-panel::-webkit-scrollbar-track,
        .console-panel::-webkit-scrollbar-track {
            background: #0a0a0a;
        }

        .scenario-panel::-webkit-scrollbar-thumb,
        .control-panel::-webkit-scrollbar-thumb,
        .console-panel::-webkit-scrollbar-thumb {
            background: #43a047;
            border-radius: 3px;
        }
        
        .scenario-panel::-webkit-scrollbar-thumb:hover,
        .control-panel::-webkit-scrollbar-thumb:hover,
        .console-panel::-webkit-scrollbar-thumb:hover {
            background: #2e7d32;
        }
        
        /* File Picker Modal */
        .file-picker-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
        }
        
        .file-picker-content {
            background-color: #2a2a2a;
            margin: 5% auto;
            padding: 0;
            border-radius: 5px;
            width: 90%;
            max-width: 800px;
            max-height: 80%;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
        }
        
        .file-picker-header {
            background: #1a1a1a;
            padding: 12px 15px;
            border-bottom: 1px solid rgba(67, 160, 71, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .file-picker-title {
            font-size: 1.1em;
            font-weight: bold;
            color: #43a047;
        }
        
        .file-picker-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #ccc;
            padding: 0;
            width: 25px;
            height: 25px;
        }
        
        .file-picker-body {
            padding: 10px;
            flex: 1;
            overflow-y: auto;
            min-height: 200px;
        }
        
        .file-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .file-item {
            display: flex;
            align-items: center;
            padding: 7px 12px;
            border: 1px solid transparent;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 2px;
            font-size: 12px;
            line-height: 1.3;
            gap: 6px;
            color: white;
        }
        
        .file-item:hover {
            background: rgba(67, 160, 71, 0.1);
            border-color: #43a047;
        }
        
        .file-item.selected {
            background: #ebf8ff;
            border-color: #3182ce;
            color: #2b6cb0;
        }
        
        .file-icon {
            font-size: 16px;
            color: #ccc;
            flex-shrink: 0;
        }
        
        .file-name {
            flex: 1;
            font-size: 12px;
        }

        .file-item input[type="checkbox"] {
            margin: 0;
            width: 16px;
            height: 16px;
            flex-shrink: 0;
            cursor: pointer;
        }

        .save-btn, .green-btn {
            background: #43a047 !important;
        }

        .save-btn:hover, .green-btn:hover {
            background: #2e7d32 !important;
        }

        /* File Upload Zone Styling */
        .file-upload-zone {
            border: 1px dashed #555;
            border-radius: 3px;
            padding: 6px 10px;
            background: #1a1a1a;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 28px;
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .file-upload-zone:hover {
            background: #222;
            border-color: #43a047;
        }

        .file-upload-zone.dragover {
            background: rgba(67, 160, 71, 0.2);
            border-color: #43a047;
            border-style: solid;
        }

        .file-upload-zone.has-file {
            background: rgba(67, 160, 71, 0.1);
            border-color: #43a047;
            border-style: solid;
        }

        .file-upload-zone.uploading {
            background: rgba(251, 192, 45, 0.1);
            border-color: #fbc02d;
            border-style: solid;
        }

        .file-upload-zone.error {
            background: rgba(229, 57, 53, 0.1);
            border-color: #e53935;
            border-style: solid;
        }

        .file-upload-zone.upload-loaded {
            background: rgba(33, 150, 243, 0.1);
            border-color: #2196F3;
            border-style: solid;
        }

        .file-upload-zone.upload-ready {
            background: rgba(33, 150, 243, 0.1);
            border-color: #2196F3;
            border-style: solid;
        }

        .file-upload-zone .upload-content {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
            text-align: left;
        }

        .file-upload-zone .upload-icon {
            font-size: 14px;
            color: #ccc;
            margin: 0;
        }

        .file-upload-zone .upload-text {
            color: #ccc;
            font-size: 11px;
            margin: 0;
        }

        .file-upload-zone .file-info {
            color: #43a047;
            font-weight: bold;
            font-size: 12px;
            margin: 0;
        }

        .file-upload-zone .upload-btn {
            background: #555 !important;
            color: white !important;
            border: none !important;
            padding: 5px 10px !important;
            border-radius: 3px !important;
            font-size: 10px !important;
            margin: 0 !important;
            width: auto !important;
            flex-shrink: 0;
        }

        .file-upload-zone .upload-btn:hover {
            background: #666 !important;
        }

        .file-upload-zone .clear-btn {
            background: #e53935 !important;
            color: white !important;
            border: none !important;
            padding: 5px 10px !important;
            border-radius: 3px !important;
            font-size: 10px !important;
            margin: 0 !important;
            margin-left: 4px !important;
            width: auto !important;
            flex-shrink: 0;
            display: none; /* Hidden by default, shown when file is present */
        }

        .file-upload-zone .clear-btn:hover {
            background: #c62828 !important;
        }

        .file-upload-zone input[type="file"] {
            display: none;
        }

        .empty-state {
            text-align: center;
            padding: 30px 15px;
            color: #888;
        }
        
        .file-picker-footer {
            padding: 12px 15px;
            border-top: 1px solid rgba(67, 160, 71, 0.3);
            background: #1a1a1a;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            flex-shrink: 0;
        }
        
        .file-picker-btn {
            padding: 7px 14px;
            border-radius: 3px;
            border: 1px solid #555;
            background: #2a2a2a;
            cursor: pointer;
            font-size: 12px;
            color: white;
        }
        
        .file-picker-btn.primary {
            background: #43a047;
            color: white;
            border-color: #43a047;
        }
        
        .file-picker-btn.primary:hover {
            background: #2e7d32;
        }
        
        .file-picker-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Custom Dialog Styles */
        .custom-dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        
        .custom-dialog-content {
            background: #2a2a2a;
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            color: white;
        }
        
        .custom-dialog-content h2 {
            margin-top: 0;
            color: #43a047;
            font-size: 21px;
            margin-bottom: 15px;
        }
        
        .custom-dialog-content p {
            line-height: 1.6;
            margin-bottom: 8px;
            font-size: 14px;
            color: #ccc;
        }
        
        .custom-dialog-content .dialog-message {
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            background: rgba(0, 0, 0, 0.3);
            padding: 16px;
            border-radius: 5px;
            margin: 15px 0;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .custom-dialog-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .custom-dialog-btn {
            flex: 1;
            padding: 13px 22px;
            border: none;
            border-radius: 6px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .custom-dialog-btn-cancel {
            background: #555;
            color: white;
        }
        
        .custom-dialog-btn-cancel:hover {
            background: #666;
        }
        
        .custom-dialog-btn-confirm {
            background: #43a047;
            color: white;
        }
        
        .custom-dialog-btn-confirm:hover {
            background: #2e7d32;
        }
        
        .custom-dialog-btn-ok {
            background: #43a047;
            color: white;
        }
        
        .custom-dialog-btn-ok:hover {
            background: #2e7d32;
        }
        
        /* Admin-only sections - hidden by default */
        .admin-only {
            display: none;
        }
        
        /* Show admin sections when body has admin class */
        body.user-admin .admin-only {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <img src="traxim button - tight.png" alt="Traxim Logo" class="header-logo">
                <h1>Traxim Control Interface</h1>
            </div>
            <div class="header-user-info">
                <!-- Hidden inputs for backend compatibility -->
                <input type="hidden" id="headerUserName">
                <input type="hidden" id="headerEmailAddress">
                <span class="user-email" id="userEmailDisplay"></span>
                <button id="logoutBtn" type="button" class="header-logout-btn" onclick="handleLogout()">
                    Logout
                </button>
            </div>
        </div>

        <div class="main-content">
            <div class="scenario-panel">
                <h2>Scenario Management</h2>
                
                <div class="scenario-section">
                    <h3>Scenarios</h3>
                    <!-- Hidden userName field for backend compatibility -->
                    <input type="hidden" id="userName" value="">
                    <div class="form-group">
                        <label for="existingScenarios">Load existing scenario from server (optional):</label>
                        <div class="dropdown-with-delete">
                            <select id="existingScenarios" onchange="loadSelectedScenario()" class="dropdown-with-button">
                                <option value="">Select scenario to load...</option>
                            </select>
                            <button type="button" class="delete-scenario-btn" onclick="deleteSelectedScenario()" disabled title="Select a scenario to delete">Delete</button>
                        </div>
                    </div>
                    <div class="scenario-button-group">
                        <button type="button" class="new-scenario-btn" onclick="clearForNewScenario()">New Scenario</button>
                        <button type="button" class="save-btn" onclick="saveScenarioAs()">Save Scenario As...</button>
                    </div>
                </div>



                <div class="scenario-section">
                    <h3>Input Files</h3>
                    <div class="form-group">
                        <label for="infrastructureFile">Infrastructure:</label>
                        <div class="file-upload-zone" data-field="infrastructure" onclick="triggerFileUpload('infrastructure')" ondrop="handleFileDrop(event, 'infrastructure')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                            <div class="upload-content">
                                <div class="upload-icon">üìÑ</div>
                                <p class="upload-text">Click or drag CSV file here</p>
                            </div>
                            <button type="button" class="upload-btn" onclick="event.stopPropagation(); triggerFileUpload('infrastructure')">Choose File</button>
                            <input type="file" id="infrastructureFile" accept=".csv" onchange="handleFileSelect(event, 'infrastructure')">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="timetable1File">Train Plan 1:</label>
                        <div class="file-upload-zone" data-field="timetable1" onclick="triggerFileUpload('timetable1')" ondrop="handleFileDrop(event, 'timetable1')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                            <div class="upload-content">
                                <div class="upload-icon">üìÑ</div>
                                <p class="upload-text">Click or drag CSV file here</p>
                            </div>
                            <button class="upload-btn" onclick="event.stopPropagation(); triggerFileUpload('timetable1')">Choose File</button>
                            <input type="file" id="timetable1File" accept=".csv" onchange="handleFileSelect(event, 'timetable1')">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="timetable2File">Train Plan 2 (optional):</label>
                        <div class="file-upload-zone" data-field="timetable2" onclick="triggerFileUpload('timetable2')" ondrop="handleFileDrop(event, 'timetable2')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                            <div class="upload-content">
                                <div class="upload-icon">üìÑ</div>
                                <p class="upload-text">Click or drag CSV file here</p>
                            </div>
                            <button class="upload-btn" onclick="event.stopPropagation(); triggerFileUpload('timetable2')">Choose File</button>
                            <button class="clear-btn" onclick="event.stopPropagation(); clearUploadedFile('timetable2')">Clear</button>
                            <input type="file" id="timetable2File" accept=".csv" onchange="handleFileSelect(event, 'timetable2')">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="timetableRulesFile">Timetable Rules:</label>
                        <div class="file-upload-zone" data-field="timetableRules" onclick="triggerFileUpload('timetableRules')" ondrop="handleFileDrop(event, 'timetableRules')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                            <div class="upload-content">
                                <div class="upload-icon">üìÑ</div>
                                <p class="upload-text">Click or drag CSV file here</p>
                            </div>
                            <button class="upload-btn" onclick="event.stopPropagation(); triggerFileUpload('timetableRules')">Choose File</button>
                            <input type="file" id="timetableRulesFile" accept=".csv" onchange="handleFileSelect(event, 'timetableRules')">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="possessionsFile">Possessions (optional):</label>
                        <div class="file-upload-zone" data-field="possessions" onclick="triggerFileUpload('possessions')" ondrop="handleFileDrop(event, 'possessions')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                            <div class="upload-content">
                                <div class="upload-icon">üìÑ</div>
                                <p class="upload-text">Click or drag CSV file here</p>
                            </div>
                            <button class="upload-btn" onclick="event.stopPropagation(); triggerFileUpload('possessions')">Choose File</button>
                            <button class="clear-btn" onclick="event.stopPropagation(); clearUploadedFile('possessions')">Clear</button>
                            <input type="file" id="possessionsFile" accept=".csv" onchange="handleFileSelect(event, 'possessions')">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="speedboardsFile">Speedboards:</label>
                        <div class="file-upload-zone" data-field="speedboards" onclick="triggerFileUpload('speedboards')" ondrop="handleFileDrop(event, 'speedboards')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                            <div class="upload-content">
                                <div class="upload-icon">üìÑ</div>
                                <p class="upload-text">Click or drag CSV file here</p>
                            </div>
                            <button class="upload-btn" onclick="event.stopPropagation(); triggerFileUpload('speedboards')">Choose File</button>
                            <input type="file" id="speedboardsFile" accept=".csv" onchange="handleFileSelect(event, 'speedboards')">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="regionsFile">Regions:</label>
                        <div class="file-upload-zone" data-field="regions" onclick="triggerFileUpload('regions')" ondrop="handleFileDrop(event, 'regions')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                            <div class="upload-content">
                                <div class="upload-icon">üìÑ</div>
                                <p class="upload-text">Click or drag CSV file here</p>
                            </div>
                            <button class="upload-btn" onclick="event.stopPropagation(); triggerFileUpload('regions')">Choose File</button>
                            <input type="file" id="regionsFile" accept=".csv" onchange="handleFileSelect(event, 'regions')">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="geometryDirectory">Geometry Directory:</label>
                        <div class="file-upload-zone" data-field="geometry" onclick="triggerFolderUpload('geometry')" ondrop="handleFolderDrop(event, 'geometry')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                            <div class="upload-icon">üìÅ</div>
                            <p class="upload-text">Click or drag folder here</p>
                            <button class="upload-btn" onclick="event.stopPropagation(); triggerFolderUpload('geometry')">Choose Folder</button>
                            <input type="file" id="geometryDirectory" webkitdirectory onchange="handleFolderSelect(event, 'geometry')">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="tractiveEffortDirectory">Tractive Effort Directory:</label>
                        <div class="file-upload-zone" data-field="tractiveEffort" onclick="triggerFolderUpload('tractiveEffort')" ondrop="handleFolderDrop(event, 'tractiveEffort')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                            <div class="upload-icon">üìÅ</div>
                            <p class="upload-text">Click or drag folder here</p>
                            <button class="upload-btn" onclick="event.stopPropagation(); triggerFolderUpload('tractiveEffort')">Choose Folder</button>
                            <input type="file" id="tractiveEffortDirectory" webkitdirectory onchange="handleFolderSelect(event, 'tractiveEffort')">
                        </div>
                    </div>
                </div>

                <div class="scenario-section">
                    <h3>Simulation Settings</h3>
                    <div class="three-column-group">
                        <div>
                            <div class="form-group">
                                <label for="dateYear">Year:</label>
                                <input type="number" id="dateYear" min="2020" max="2050" value="2025">
                            </div>
                            <div class="form-group">
                                <label for="dateQuarter">Quarter:</label>
                                <select id="dateQuarter">
                                    <option value="1">Q1</option>
                                    <option value="2">Q2</option>
                                    <option value="3">Q3</option>
                                    <option value="4">Q4</option>
                                </select>
                            </div>
                        </div>
                        <div>
                            <div class="form-group">
                                <label for="windowDays">Window Days:</label>
                                <input type="number" id="windowDays" min="1" max="365" value="7">
                            </div>
                            <div class="form-group">
                                <label for="simulationDays">Simulation Days:</label>
                                <input type="number" id="simulationDays" min="1" max="21" value="10">
                            </div>
                        </div>
                        <div>
                            <div class="form-group">
                                <label for="initialSeed">Initial Seed:</label>
                                <input type="number" id="initialSeed" min="1" max="99" value="0">
                            </div>
                            <div class="form-group">
                                <label for="perturbations">Perturbations:</label>
                                <input type="number" id="perturbations" min="0" max="50" value="1">
                            </div>
                        </div>
                    </div>
                    <div class="single-row-checkboxes">
                        <label>
                            <input type="checkbox" id="linkSplitting"> Link Splitting
                        </label>
                        <label>
                            <input type="checkbox" id="autoCurveSpeedLimiting" checked onchange="ensureSessionExistsSync()"> Auto Curve Speed
                        </label>
                        <label>
                            <input type="checkbox" id="wrapping" onchange="ensureSessionExistsSync()"> Timetable Wrap
                        </label>
                    </div>
                    <div class="form-group">
                        <label for="linkSplittingDistance">Splitting Distance (km):</label>
                        <input type="number" id="linkSplittingDistance" step="0.1" min="0" value="3.0" style="width: 100px;">
                    </div>
                </div>

                <div class="scenario-section admin-only">
                    <h3>Advanced Settings</h3>
                    <div class="form-group" style="display: none;">
                        <label for="executablePath">Executable Path:</label>
                        <input type="text" id="executablePath" value="/opt/traxim/net9.0/TraximCli.dll" readonly style="background-color: #1a1a1a; color: #888;">
                    </div>
                    <div class="form-group" style="display: none;">
                        <label for="scenarioPath">Scenarios Folder:</label>
                        <input type="text" id="scenarioPath" value="" readonly style="background-color: #1a1a1a; color: #888;">
                    </div>
                    <div class="inline-group">
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="liveMode" onchange="ensureSessionExistsSync()"> Live Mode
                            </label>
                        </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="writeHotStartTimesCSV" onchange="ensureSessionExistsSync()"> write HotStartTimesCSV
                            </label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="liveLocationsFile">Live Locations (optional):</label>
                        <div class="file-upload-zone" data-field="liveLocations" onclick="triggerFileUpload('liveLocations')" ondrop="handleFileDrop(event, 'liveLocations')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                            <div class="upload-content">
                                <span class="upload-icon">üìÑ</span>
                                <span class="upload-text">Drop Live Locations file here or click to browse</span>
                            </div>
                            <button class="upload-btn" onclick="event.stopPropagation(); triggerFileUpload('liveLocations')">Choose File</button>
                            <button class="clear-btn" onclick="event.stopPropagation(); clearUploadedFile('liveLocations')">Clear</button>
                        </div>
                        <input type="file" id="liveLocationsFile" accept=".csv,.txt" style="display: none;" onchange="handleFileSelect(event, 'liveLocations')">
                    </div>
                </div>


            </div>

            <div class="control-panel">
                <h2>Simulation Management</h2>
                
                <div class="scenario-section">
                    <h3>Scenario Submission</h3>
                    <div class="form-group">
                        <label for="scenarioFile">Scenario File:</label>
                        <div class="inline-input-group">
                            <select id="scenarioFile" onchange="updateOutputsFolder(); updateSessionId(); saveSettings();">
                                <option value="">Select scenario file...</option>
                            </select>
                        </div>
                    </div>

                    <div class="button-group">
                        <button type="button" class="green-btn" onclick="validateScenario()">Validate</button>
                        <button type="button" class="green-btn" onclick="runOnce()">Resolve</button>
                    </div>
                </div>

                <div class="scenario-section">
                    <h3>Simulation Outputs</h3>
                    <div class="form-group">
                        <label for="outputsFolder">Outputs Folder:</label>
                        <div class="inline-input-group">
                            <input type="text" id="outputsFolder" placeholder="Upload files or select scenario to see outputs folder" value="" readonly>
                        </div>
                    </div>
                    <div class="button-group">
                        <button type="button" class="green-btn" onclick="aggregateResults()">Aggregate Results</button>
                        <button type="button" class="green-btn" onclick="openDownloadPicker()">Download Results</button>
                    </div>
                </div>

                <div class="scenario-section auto-schedule admin-only">
                    <h3>Live Mode: Auto Schedule</h3>
                    <div class="form-group">
                        <label for="updateInterval">Update Interval (minutes):</label>
                        <input type="number" id="updateInterval" min="1" max="60" value="10">
                    </div>
                    <div class="button-group">
                        <button type="button" class="green-btn" onclick="startAutoSchedule()">Start Auto Schedule</button>
                        <button type="button" class="green-btn" onclick="stopAutoSchedule()">Stop Auto Schedule</button>
                    </div>
                    
                    <h3>Status</h3>
                    <div id="status" class="status idle">
                        System Ready
                    </div>
                    
                    <div class="schedule-info">
                        <div class="schedule-stat">
                            <span id="currentTime" class="value">0</span>
                            <span class="label">Current Time</span>
                        </div>
                        <div class="schedule-stat">
                            <span id="nextRun" class="value">--:--</span>
                            <span class="label">Next Run</span>
                        </div>
                        <div class="schedule-stat">
                            <span id="runCount" class="value">0</span>
                            <span class="label">Runs Completed</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="console-panel">
                <h2>Console Output</h2>
                <div id="output" class="output-area">
                    <div class="output-line timestamp">[System Ready]</div>
                    <div class="output-line info">Waiting for commands...</div>
                </div>
            </div>

        </div>
    </div>

    <script>
        let autoScheduleInterval = null;
        let runCount = 0;
        let isRunning = false;

        // Detect the host url - include port for local development
        // In production, nginx proxies /api/ to localhost:3000 (no port needed)
        const serverUrl = window.location.port 
            ? `${window.location.protocol}//${window.location.hostname}:${window.location.port}`
            : `${window.location.protocol}//${window.location.hostname}`;
        
        // Global user state
        let currentUser = null;
        let isGuest = false;
        let isAdmin = false;
        
        // Custom Dialog Functions
        function showCustomConfirm(title, message) {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'custom-dialog-overlay';
                
                const content = document.createElement('div');
                content.className = 'custom-dialog-content';
                
                content.innerHTML = `
                    <h2>${title}</h2>
                    <div class="dialog-message">${message}</div>
                    <div class="custom-dialog-buttons">
                        <button class="custom-dialog-btn custom-dialog-btn-cancel" onclick="this.closest('.custom-dialog-overlay').remove()">Cancel</button>
                        <button class="custom-dialog-btn custom-dialog-btn-confirm">OK</button>
                    </div>
                `;
                
                overlay.appendChild(content);
                document.body.appendChild(overlay);
                
                const confirmBtn = content.querySelector('.custom-dialog-btn-confirm');
                const cancelBtn = content.querySelector('.custom-dialog-btn-cancel');
                
                confirmBtn.onclick = () => {
                    overlay.remove();
                    resolve(true);
                };
                
                cancelBtn.onclick = () => {
                    overlay.remove();
                    resolve(false);
                };
                
                // Close on overlay click
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        overlay.remove();
                        resolve(false);
                    }
                };
            });
        }
        
        function showCustomAlert(title, message) {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'custom-dialog-overlay';
                
                const content = document.createElement('div');
                content.className = 'custom-dialog-content';
                
                content.innerHTML = `
                    <h2>${title}</h2>
                    <div class="dialog-message">${message}</div>
                    <div class="custom-dialog-buttons">
                        <button class="custom-dialog-btn custom-dialog-btn-ok">OK</button>
                    </div>
                `;
                
                overlay.appendChild(content);
                document.body.appendChild(overlay);
                
                const okBtn = content.querySelector('.custom-dialog-btn-ok');
                
                okBtn.onclick = () => {
                    overlay.remove();
                    resolve();
                };
                
                // Close on overlay click
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        overlay.remove();
                        resolve();
                    }
                };
            });
        }
        
        // Check authentication status on page load
        async function checkAuthentication() {
            try {
                const response = await fetch(`${serverUrl}/api/auth/status`, {
                    credentials: 'include'
                });
                const data = await response.json();
                
                if (!data.authenticated) {
                    // Not authenticated, redirect to login
                    window.location.href = '/login.html';
                    return false;
                }
                
                currentUser = data.user;
                isGuest = data.user.isGuest;
                isAdmin = data.user.role === 'admin';
                
                // Apply role-based visibility
                applyRoleBasedUI();
                
                // Populate header fields
                document.getElementById('headerUserName').value = data.user.folder;
                document.getElementById('headerEmailAddress').value = data.user.email;
                document.getElementById('userEmailDisplay').textContent = data.user.email;
                
                // Set hidden username field for backend compatibility
                if (isGuest) {
                    document.getElementById('userName').value = 'guest';
                    showGuestWarning();
                } else {
                    // Use the folder name from the authenticated user
                    document.getElementById('userName').value = data.user.folder;
                }
                
                // Update scenario and upload paths
                updateScenarioPath();
                updateUploadPathOnly();
                
                return true;
            } catch (error) {
                console.error('Auth check failed:', error);
                // Development mode: If server isn't running, use guest mode
                console.warn('Backend not available. Running in development mode as guest.');
                currentUser = { email: 'dev@local', folder: 'guest', isGuest: true };
                isGuest = true;
                isAdmin = false;
                document.getElementById('headerUserName').value = 'guest';
                document.getElementById('headerEmailAddress').value = 'dev@local';
                document.getElementById('userEmailDisplay').textContent = 'dev@local (Development Mode)';
                document.getElementById('userName').value = 'guest';
                showGuestWarning();
                updateScenarioPath();
                updateUploadPathOnly();
                return true;
            }
        }
        
        // Show guest warning banner
        function showGuestWarning() {
            const warningHtml = `
                <div style="background: rgba(255, 235, 59, 0.2); border: 1px solid #fbc02d; border-radius: 5px; padding: 10px; margin: 8px; color: #fdd835; font-size: 11px;">
                    <strong>‚ö†Ô∏è Guest Mode:</strong> You can explore the interface and validate scenarios, but cannot resolve timetables. 
                    Your files are stored in a public folder visible to all users.
                    <span style="margin-left: 8px;">Log out and create an account for full access.</span>
                </div>
            `;
            
            const container = document.querySelector('.container');
            const header = container.querySelector('.header');
            header.insertAdjacentHTML('afterend', warningHtml);
        }
        
        // Apply role-based UI visibility
        function applyRoleBasedUI() {
            if (isAdmin) {
                document.body.classList.add('user-admin');
                console.log('Admin access granted - showing advanced features');
            } else {
                document.body.classList.remove('user-admin');
                console.log('Standard user - hiding admin-only features');
            }
        }
        
        // Add global error handlers to prevent page reloads from unhandled errors
        window.addEventListener('error', function(event) {
            console.error('Global error caught:', event.error);
            console.error('Error details:', {
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno,
                stack: event.error?.stack
            });
            // Prevent the error from causing a page reload
            event.preventDefault();
            return false;
        });
        
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled promise rejection:', event.reason);
            console.error('Promise rejection details:', event);
            // Prevent the rejection from causing a page reload
            event.preventDefault();
            return false;
        });
        
        // Add navigation debugging
        window.addEventListener('beforeunload', function(event) {
            console.warn('Page is about to unload/reload!');
            console.trace('beforeunload triggered from:');
        });
        
        // Add click debugging to identify problematic buttons
        document.addEventListener('click', function(event) {
            const target = event.target;
            console.log('Click detected on:', {
                tagName: target.tagName,
                type: target.type,
                onclick: target.onclick ? target.onclick.toString().substring(0, 100) + '...' : 'none',
                className: target.className,
                id: target.id,
                href: target.href,
                defaultPrevented: event.defaultPrevented
            });
            
            // Check for potentially problematic elements
            if (target.tagName === 'BUTTON' && target.type !== 'button') {
                console.warn('Button without explicit type="button" detected - may cause form submission!', target);
            }
            
            if (target.tagName === 'A' && !event.defaultPrevented) {
                console.warn('Link click not prevented - may cause navigation!', target);
            }
        }, true);

        // Load saved settings
        window.addEventListener('DOMContentLoaded', async function() {
            // Check authentication first
            const authenticated = await checkAuthentication();
            if (!authenticated) {
                return; // Will redirect to login
            }
            
            // Fix all buttons to prevent form submission
            const buttons = document.querySelectorAll('button:not([type])');
            buttons.forEach(button => {
                button.type = 'button';
                console.log('Fixed button type for:', button.textContent.trim());
            });
            
            loadSettings();
            
            // Start periodic session cleanup (every 30 minutes)
            startSessionCleanup();
            
            // Refresh dropdowns only if required settings are available
            setTimeout(() => {
                const scenarioPath = document.getElementById('scenarioPath').value;
                const userName = document.getElementById('userName').value;
                
                console.log('Page load dropdown refresh - scenarioPath:', scenarioPath, 'userName:', userName);
                
                if (scenarioPath && scenarioPath.trim()) {
                    console.log('Calling refreshScenarios()');
                    refreshScenarios();
                } else {
                    console.log('Skipping refreshScenarios - no scenarioPath');
                }
                
                if (userName && userName.trim()) {
                    console.log('Calling refreshExistingScenarios()');
                    refreshExistingScenarios();
                } else {
                    console.log('Skipping refreshExistingScenarios - no userName');
                }
            }, 100); // Small delay to ensure settings are loaded
        });

        function loadSettings() {
            const interval = localStorage.getItem('updateInterval');
            const selectedScenario = localStorage.getItem('selectedScenarioFile');
            
            // Always set the standard executable path
            document.getElementById('executablePath').value = '/opt/traxim/net9.0/TraximCli.dll';
            
            if (interval) document.getElementById('updateInterval').value = interval;
            
            // Username is set from authentication in checkAuthentication()
            // Scenario path and upload path are set after authentication completes
            
            // Store selected scenario for restoration after dropdown is populated
            if (selectedScenario) {
                window.pendingScenarioSelection = selectedScenario;
                console.log('Stored pending scenario selection:', selectedScenario);
            }
        }

        function saveSettings() {
            // No need to save executablePath and scenarioPath since they're auto-generated
            localStorage.setItem('updateInterval', document.getElementById('updateInterval').value);
            localStorage.setItem('userName', document.getElementById('userName').value);
            localStorage.setItem('selectedScenarioFile', document.getElementById('scenarioFile').value);
        }

        // Function to update scenario path when username changes
        function updateScenarioPath() {
            const userName = document.getElementById('userName').value.trim();
            if (userName) {
                document.getElementById('scenarioPath').value = `/opt/traxim/input-data/${userName.toLowerCase()}/`;
                console.log('Updated scenario path for user:', userName);
            } else {
                document.getElementById('scenarioPath').value = '';
            }
        }
        
        // Set up the current time timer.
        setInterval(updateCurrentTime, 1000);
        updateCurrentTime();
        
        // Debug function to check scenario selection state
        function checkScenarioState() {
            const executablePath = document.getElementById('executablePath').value;
            const scenarioPath = document.getElementById('scenarioPath').value;
            const scenarioFile = document.getElementById('scenarioFile').value;
            const interval = document.getElementById('updateInterval').value;
            
            console.log('Current form state:', {
                executablePath: executablePath || 'MISSING',
                scenarioPath: scenarioPath || 'MISSING', 
                scenarioFile: scenarioFile || 'MISSING',
                interval: interval || 'MISSING',
                pendingSelection: window.pendingScenarioSelection || 'none'
            });
            
            addOutput(`Form state: Executable: ${executablePath ? '‚úì' : '‚úó'} (auto), Scenario Path: ${scenarioPath ? '‚úì' : '‚úó'} (auto), Scenario File: ${scenarioFile ? '‚úì' : '‚úó'}, Interval: ${interval ? '‚úì' : '‚úó'}`, 'info');
        } 

        async function refreshScenarios() {
            const scenarioPath = document.getElementById('scenarioPath').value;
            if (!scenarioPath) {
                addOutput('Please set the scenarios folder path first', 'error');
                return;
            }

            try {
                // If node.js is running on a local server use the following fetch call.
                //const response = await fetch('http://localhost:3000/api/scenarios', {
                // If it is running on a remote server use the following fetch call.
                const response = await fetch(`${serverUrl}/api/scenarios`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: scenarioPath })
                });

                const result = await response.json();
                const select = document.getElementById('scenarioFile');
                select.innerHTML = '<option value="">Select scenario file...</option>';

                if (result.success) {
                    result.files.forEach(file => {
                        const option = document.createElement('option');
                        option.value = file;
                        option.textContent = file;
                        select.appendChild(option);
                    });
                    
                    // Restore previously selected scenario if available
                    if (window.pendingScenarioSelection) {
                        const foundOption = result.files.find(file => file === window.pendingScenarioSelection);
                        if (foundOption) {
                            select.value = window.pendingScenarioSelection;
                            console.log('Restored scenario selection:', window.pendingScenarioSelection);
                            // Trigger the change event to update sessionId
                            updateSessionId();
                            // Load the scenario data to populate perturbations and other fields
                            console.log('Auto-loading scenario data for restored selection...');
                            await loadScenario();
                            // Note: loadScenario() internally calls updateOutputsFolder via populateScenarioData,
                            // so we don't need to call updateOutputsFolder() separately here
                        } else {
                            console.log('Previously selected scenario not found in current list:', window.pendingScenarioSelection);
                        }
                        window.pendingScenarioSelection = null; // Clear after attempting to restore
                    }
                    
                    addOutput(`Found ${result.files.length} scenario files`, 'info');
                } else {
                    addOutput(`Error loading scenarios: ${result.error}`, 'error');
                }
            } catch (error) {
                addOutput(`Failed to connect to backend: ${error.message}`, 'error');
                addOutput('Make sure the Node.js server is running on port 3000', 'error');
            }
        }

        async function runOnce() {
            return await runSimulation(true); // Manual submission - show pricing
        }
        
        async function runOnceAutoSchedule() {
            return await runSimulation(false); // Auto schedule - skip pricing
        }
        
        async function runSimulation(showPricing = true) {
            // Block guests from running
            if (isGuest) {
                addOutput('Guest users cannot run scenarios. Please sign in to execute simulations.', 'error');
                setStatus('error', 'Guest users cannot run scenarios');
                
                // Show modal prompting to sign in
                const shouldLogin = await showCustomConfirm('Guest Mode Limitation', 'Guest users cannot run simulations.\n\nWould you like to sign in now for full access?');
                if (shouldLogin) {
                    window.location.href = '/login.html';
                }
                return;
            }
            
            if (isRunning) {
                addOutput('Program is already running', 'error');
                return;
            }

            const executablePath = document.getElementById('executablePath').value;
            const scenarioPath = document.getElementById('scenarioPath').value;
            const scenarioFile = document.getElementById('scenarioFile').value;

            if (!executablePath || !scenarioPath || !scenarioFile) {
                addOutput('Please fill in all required fields', 'error');
                return;
            }
            
            // Set current session ID for pricing tracking
            // Use uploadSession if available, otherwise extract from scenario file name
            if (window.uploadSession) {
                window.currentSessionId = window.uploadSession.toString();
            } else if (scenarioFile) {
                // For loaded scenarios, use scenario name as session identifier
                window.currentSessionId = scenarioFile.replace('.scn', '');
            } else {
                window.currentSessionId = 'default';
            }
            
            console.log('[SESSION] Resolve - sessionId:', window.currentSessionId, '| uploadSession:', window.uploadSession, '| scenarioFile:', scenarioFile);
            
            // Show pricing dialog for manual submissions only
            if (showPricing) {
                // Get current session ID and perturbations
                const sessionId = window.currentSessionId;
                const perturbations = parseInt(document.getElementById('perturbations').value) || 1;
                
                // Show pricing dialog and wait for confirmation
                const confirmed = await showPricingDialog(sessionId, perturbations, scenarioFile);
                if (!confirmed) {
                    addOutput('Simulation cancelled by user', 'info');
                    return;
                }
            }

            saveSettings();
            setStatus('running', 'Running simulation...');
            isRunning = true;
            
            const fullScenarioPath = `${scenarioPath}/${scenarioFile}`;
            
            try {
                addOutput(`Starting: ${executablePath} local --project "${fullScenarioPath}"`, 'info');
                
                // Use fetch with streaming for Server-Sent Events
                const response = await fetch(`${serverUrl}/api/run`, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'text/event-stream'
                    },
                    credentials: 'include',
                    keepalive: false, // Important: don't use keepalive for streaming
                    body: JSON.stringify({
                        executable: executablePath,
                        scenario: fullScenarioPath,
                        autoSchedule: !showPricing  // true if called from Auto-Schedule
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                
                // Read streaming response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let finalResult = null;
                
                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        
                        if (done) break;
                        
                        // Decode chunk and add to buffer
                        buffer += decoder.decode(value, { stream: true });
                        
                        // Process complete SSE messages
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || ''; // Keep incomplete message in buffer
                        
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.slice(6));
                                    
                                    switch (data.type) {
                                        case 'connected':
                                            addOutput('Connected to server stream', 'info');
                                            break;
                                        case 'stdout':
                                            addOutput(data.data, 'info');
                                            break;
                                        case 'stderr':
                                            addOutput(data.data, 'info');
                                            break;
                                        case 'complete':
                                            finalResult = data.data;
                                            if (data.data.success) {
                                                addOutput('Program completed successfully', 'info');
                                                setStatus('success', 'Simulation completed successfully');
                                                runCount++;
                                                const runCountElement = document.getElementById('runCount');
                                                if (runCountElement) {
                                                    runCountElement.textContent = runCount;
                                                }
                                            } else {
                                                addOutput(`Error: ${data.data.error}`, 'error');
                                                setStatus('error', 'Simulation failed');
                                            }
                                            break;
                                        case 'error':
                                            addOutput(`Error: ${data.data.error}`, 'error');
                                            setStatus('error', 'Process error');
                                            finalResult = data.data;
                                            break;
                                        case 'timeout':
                                            addOutput('Process timed out after 12 minutes', 'error');
                                            setStatus('error', 'Process timed out');
                                            finalResult = data.data;
                                            break;
                                    }
                                } catch (e) {
                                    console.error('Error parsing SSE message:', e, line);
                                }
                            }
                        }
                    }
                } catch (readError) {
                    console.error('Error reading stream:', readError);
                    addOutput(`Stream error: ${readError.message}`, 'error');
                } finally {
                    reader.releaseLock();
                }
                
            } catch (error) {
                console.error('Fetch error:', error);
                addOutput(`Failed to run program: ${error.message}`, 'error');
                setStatus('error', 'Failed to connect to backend');
            } finally {
                isRunning = false;
                setTimeout(() => {
                    if (!autoScheduleInterval) {
                        setStatus('idle', 'System Ready');
                    }
                }, 3000);
            }
        }

        async function validateScenario() {
            if (isRunning) {
                addOutput('Program is already running', 'error');
                return;
            }

            const executablePath = document.getElementById('executablePath').value;
            const scenarioPath = document.getElementById('scenarioPath').value;
            const scenarioFile = document.getElementById('scenarioFile').value;

            if (!executablePath || !scenarioPath || !scenarioFile) {
                addOutput('Please fill in all required fields', 'error');
                return;
            }
            
            // Set current session ID for pricing tracking
            // Use uploadSession if available, otherwise extract from scenario file name
            if (window.uploadSession) {
                window.currentSessionId = window.uploadSession.toString();
            } else if (scenarioFile) {
                // For loaded scenarios, use scenario name as session identifier
                window.currentSessionId = scenarioFile.replace('.scn', '');
            } else {
                window.currentSessionId = 'default';
            }
            
            console.log('[SESSION] Validate - sessionId:', window.currentSessionId, '| uploadSession:', window.uploadSession, '| scenarioFile:', scenarioFile);

            saveSettings();
            setStatus('running', 'Validating scenario...');
            isRunning = true;
            
            const fullScenarioPath = `${scenarioPath}/${scenarioFile}`;
            
            try {
                addOutput(`Validating: ${executablePath} local --project "${fullScenarioPath}" --validate true`, 'info');
                
                const response = await fetch(`${serverUrl}/api/run`, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'text/event-stream'
                    },
                    credentials: 'include',
                    keepalive: false, // Important: don't use keepalive for streaming
                    body: JSON.stringify({
                        executable: executablePath,
                        scenario: fullScenarioPath,
                        validate: true
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                // Read streaming response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let finalResult = null;
                let detectedConflictCount = null; // Track conflict count from stdout
                
                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        
                        if (done) break;
                        
                        // Decode chunk and add to buffer
                        buffer += decoder.decode(value, { stream: true });
                        
                        // Process complete SSE messages
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || ''; // Keep incomplete message in buffer
                        
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.slice(6));
                                    
                                    switch (data.type) {
                                        case 'connected':
                                            addOutput('Connected to server stream', 'info');
                                            break;
                                        case 'stdout':
                                            addOutput(data.data, 'info');
                                            
                                            // Parse conflict count from validation output
                                            const conflictMatch = data.data.match(/(?:Total\s+conflicts|Conflicts\s+found)[:\s]+(\d+)/i);
                                            if (conflictMatch) {
                                                detectedConflictCount = parseInt(conflictMatch[1]);
                                            }
                                            break;
                                        case 'stderr':
                                            addOutput(data.data, 'info');
                                            break;
                                        case 'complete':
                                            finalResult = data.data;
                                            if (data.data.success) {
                                                addOutput('Scenario validation completed successfully', 'info');
                                                
                                                // Store validation result with conflict count
                                                if (data.data.isValidation && data.data.conflictCount !== undefined) {
                                                    const sessionId = window.currentSessionId;
                                                    const scenarioFile = document.getElementById('scenarioFile').value;
                                                    addOutput(`Conflicts detected: ${data.data.conflictCount}`, 'info');
                                                    storeValidationResult(sessionId, scenarioFile, data.data.conflictCount, true);
                                                }
                                                
                                                setStatus('success', 'Scenario validation completed successfully');
                                            } else {
                                                addOutput(`Validation Error: ${data.data.error}`, 'error');
                                                setStatus('error', 'Scenario validation failed');
                                                
                                                // Store failed validation
                                                if (data.data.isValidation) {
                                                    const sessionId = window.currentSessionId;
                                                    const scenarioFile = document.getElementById('scenarioFile').value;
                                                    storeValidationResult(sessionId, scenarioFile, 0, false);
                                                }
                                            }
                                            break;
                                        case 'error':
                                            addOutput(`Error: ${data.data.error}`, 'error');
                                            setStatus('error', 'Validation error');
                                            finalResult = data.data;
                                            break;
                                        case 'timeout':
                                            addOutput('Validation timed out after 12 minutes', 'error');
                                            setStatus('error', 'Validation timed out');
                                            finalResult = data.data;
                                            break;
                                    }
                                } catch (e) {
                                    console.error('Error parsing SSE message:', e, line);
                                }
                            }
                        }
                    }
                } catch (readError) {
                    console.error('Error reading validation stream:', readError);
                    addOutput(`Stream error: ${readError.message}`, 'error');
                } finally {
                    reader.releaseLock();
                    
                    // If we didn't get a completion event but we detected conflicts from stdout, create a synthetic result
                    if (!finalResult && detectedConflictCount !== null) {
                        finalResult = {
                            success: true,
                            conflictCount: detectedConflictCount,
                            isValidation: true,
                            message: 'Validation completed (conflicts detected from stdout)'
                        };
                        
                        // Store validation result
                        const sessionId = window.currentSessionId;
                        const scenarioFile = document.getElementById('scenarioFile').value;
                        addOutput(`Conflicts detected: ${detectedConflictCount}`, 'info');
                        storeValidationResult(sessionId, scenarioFile, detectedConflictCount, true);
                        addOutput('Scenario validation completed successfully', 'info');
                        setStatus('success', 'Scenario validation completed successfully');
                    }
                }
                
            } catch (error) {
                console.error('Validation fetch error:', error);
                addOutput(`Validation failed: ${error.message}`, 'error');
                setStatus('error', 'Validation failed');
            } finally {
                isRunning = false;
                setTimeout(() => {
                    if (!autoScheduleInterval) {
                        setStatus('idle', 'System Ready');
                    }
                }, 3000);
            }
        }

        function startAutoSchedule() {
            if (autoScheduleInterval) {
                addOutput('Auto schedule is already running', 'error');
                return;
            }

            const interval = parseInt(document.getElementById('updateInterval').value);
            if (!interval || interval < 1) {
                addOutput('Please set a valid update interval', 'error');
                return;
            }

            // Save settings before starting to ensure scenario selection is preserved
            saveSettings();
            
            // Check if scenario file is selected, if not try to give dropdown time to populate
            const scenarioFile = document.getElementById('scenarioFile').value;
            if (!scenarioFile && window.pendingScenarioSelection) {
                addOutput('Waiting for scenario dropdown to populate...', 'info');
                setTimeout(() => {
                    startAutoSchedule(); // Retry after dropdown has time to populate
                }, 500);
                return;
            }

            // Run immediately on start
            if (!isRunning) {
                updateNextRunTime();
                runOnceAutoSchedule();
            }

            autoScheduleInterval = setInterval(() => {
                if (!isRunning) {
                    updateNextRunTime();
                    runOnceAutoSchedule();
                }
            }, interval * 60 * 1000);

            addOutput(`Auto schedule started - running every ${interval} minutes`, 'info');
            setStatus('running', `Auto schedule active (${interval}m intervals)`);
            updateNextRunTime();
        }

        function stopAutoSchedule() {
            if (!autoScheduleInterval) {
                addOutput('Auto schedule is not running', 'error');
                return;
            }

            clearInterval(autoScheduleInterval);
            autoScheduleInterval = null;
            addOutput('Auto schedule stopped', 'info');
            setStatus('idle', 'System Ready');
            document.getElementById('nextRun').textContent = '--:--';
        }

        function updateNextRunTime() {
            if (autoScheduleInterval) {
                const interval = parseInt(document.getElementById('updateInterval').value);
                const nextRun = new Date(Date.now() + interval * 60 * 1000);
                document.getElementById('nextRun').textContent = nextRun.toLocaleTimeString();
            }
        }

        // Update current time every second
        function updateCurrentTime() {
            const now = new Date();
            const h = now.getHours();
            const m = String(now.getMinutes()).padStart(2, '0');
            const s = String(now.getSeconds()).padStart(2, '0');
            document.getElementById('currentTime').textContent = `${h}:${m}:${s}`;
        }

        function setStatus(type, message) {
            const statusElement = document.getElementById('status');
            statusElement.className = `status ${type}`;
            statusElement.textContent = message;
        }

        function addOutput(message, type = 'info') {
            const outputElement = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            const line = document.createElement('div');
            line.className = `output-line ${type}`;
            line.textContent = `[${timestamp}] ${message}`;
            
            outputElement.appendChild(line);
            outputElement.scrollTop = outputElement.scrollHeight;

            // Keep only last 100 lines
            while (outputElement.children.length > 100) {
                outputElement.removeChild(outputElement.firstChild);
            }
        }

        // File Upload and Scenario Management Functions
        
        function updateWorkingMode() {
            const mode = document.getElementById('workingMode').value;
            const localDirGroup = document.getElementById('localDirectoryGroup');
            
            if (mode === 'local') {
                localDirGroup.style.display = 'block';
            } else {
                localDirGroup.style.display = 'none';
            }
        }
        
        async function browseLocalDirectory() {
            // Create a hidden file input for .scn file selection
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.scn';
            input.style.display = 'none';
            
            input.onchange = async function(event) {
                const file = event.target.files[0];
                if (file && file.name.toLowerCase().endsWith('.scn')) {
                    try {
                        addOutput(`Loading scenario file: ${file.name}...`, 'info');
                        
                        // Read the file content
                        const reader = new FileReader();
                        reader.onload = async function(e) {
                            const content = e.target.result;
                            
                            // Update the local scenario path with the file directory (or just filename)

                            
                            // Parse the scenario content using existing functionality
                            try {
                                await populateScenarioData(content);
                                addOutput(`Scenario ${file.name} loaded successfully into form`, 'success');
                            } catch (parseError) {
                                addOutput(`Error parsing scenario file: ${parseError.message}`, 'error');
                            }
                        };
                        
                        reader.onerror = function() {
                            addOutput(`Error reading file: ${file.name}`, 'error');
                        };
                        
                        // Read the file as text
                        reader.readAsText(file);
                        
                    } catch (error) {
                        addOutput(`Error loading scenario file: ${error.message}`, 'error');
                    }
                } else if (file) {
                    addOutput('Please select a .scn file', 'error');
                }
                document.body.removeChild(input);
            };
            
            input.onerror = function() {
                addOutput('File selection cancelled or failed', 'info');
                document.body.removeChild(input);
            };
            
            document.body.appendChild(input);
            input.click();
        }
        
        async function refreshExistingScenarios() {
            const userName = document.getElementById('userName').value;
            
            if (!userName.trim()) {
                addOutput('Please enter your username first', 'error');
                return;
            }
            
            try {
                let scenarios = [];
                
                // Get remote scenarios
                const response = await fetch(`${serverUrl}/api/scenarios/user`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        userName: userName.trim(),
                        scenarioPath: document.getElementById('scenarioPath').value 
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    scenarios = result.scenarios || [];
                }
                

                
                // Populate dropdown
                const select = document.getElementById('existingScenarios');
                select.innerHTML = '<option value="">Select scenario to load...</option>';
                
                scenarios.forEach(scenario => {
                    const option = document.createElement('option');
                    option.value = scenario;
                    option.textContent = scenario;
                    select.appendChild(option);
                });
                
                // Update delete button state after populating dropdown
                updateDeleteButtonState();
                
                addOutput(`Loaded ${scenarios.length} scenarios for user: ${userName}`, 'info');
                
            } catch (error) {
                addOutput(`Error loading scenarios: ${error.message}`, 'error');
            }
        }
        
        async function loadSelectedScenario() {
            const selectedScenario = document.getElementById('existingScenarios').value;
            updateDeleteButtonState(); // Update delete button state when selection changes
            
            if (!selectedScenario) {
                // Reset upload zones when no scenario is selected (New Scenario)
                clearForNewScenario();
                return;
            }
            
            const userName = document.getElementById('userName').value;
            const scenarioPath = document.getElementById('scenarioPath').value;
            
            try {
                const response = await fetch(`${serverUrl}/api/scenario/load`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        name: selectedScenario, 
                        userName: userName.trim(),
                        scenarioPath 
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    console.log('Server response result:', result);
                    console.log('Server response result.data type:', typeof result.data);
                    console.log('Server response result.data content:', result.data);
                    await populateScenarioData(result.data);
                    addOutput(`Loaded scenario: ${selectedScenario}`, 'info');
                    
                    // Update the main scenario dropdown
                    const mainSelect = document.getElementById('scenarioFile');
                    mainSelect.value = selectedScenario;
                    
                    // The outputs folder is updated by the populate functions, but ensure it's called
                    console.log('Scenario loaded successfully, outputs folder should be updated');
                } else {
                    addOutput(`Failed to load scenario: ${result.error}`, 'error');
                }
            } catch (error) {
                addOutput(`Scenario load error: ${error.message}`, 'error');
            }
        }
        
        async function deleteSelectedScenario() {
            const selectedScenario = document.getElementById('existingScenarios').value;
            if (!selectedScenario) {
                addOutput('No scenario selected for deletion', 'error');
                return;
            }
            
            // Confirm deletion
            const confirmDelete = await showCustomConfirm('Delete Scenario', `Are you sure you want to delete the scenario "${selectedScenario}"?\n\nThis action cannot be undone. The associated session will be cleaned up automatically by the cleanup process.`);
            if (!confirmDelete) {
                return;
            }
            
            const userName = document.getElementById('userName').value;
            const scenarioPath = document.getElementById('scenarioPath').value;
            
            try {
                const response = await fetch(`${serverUrl}/api/scenario/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        name: selectedScenario, 
                        userName: userName.trim(),
                        scenarioPath 
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    addOutput(`Deleted scenario: ${selectedScenario}`, 'info');
                    
                    // Clear the current selection and refresh the dropdown
                    document.getElementById('existingScenarios').value = '';
                    updateDeleteButtonState();
                    
                    // Refresh both dropdown lists
                    await refreshScenarios();
                    await refreshExistingScenarios();
                    
                    // If the deleted scenario was loaded, clear the form
                    const mainSelect = document.getElementById('scenarioFile');
                    if (mainSelect && mainSelect.value === selectedScenario) {
                        clearForNewScenario();
                        mainSelect.value = '';
                    }
                    
                    // Trigger a cleanup check (the cleanup will happen automatically within 30 minutes)
                    addOutput('Associated session will be cleaned up automatically by the cleanup process', 'info');
                    
                } else {
                    addOutput(`Failed to delete scenario: ${result.error}`, 'error');
                }
            } catch (error) {
                addOutput(`Scenario delete error: ${error.message}`, 'error');
            }
        }
        
        function updateDeleteButtonState() {
            const selectedScenario = document.getElementById('existingScenarios').value;
            const deleteBtn = document.querySelector('.delete-scenario-btn');
            
            if (deleteBtn) {
                if (selectedScenario) {
                    deleteBtn.disabled = false;
                    deleteBtn.title = `Delete scenario: ${selectedScenario}`;
                } else {
                    deleteBtn.disabled = true;
                    deleteBtn.title = 'Select a scenario to delete';
                }
            }
        }
        
        function clearForNewScenario() {
            // Clear the scenario selection dropdown
            document.getElementById('existingScenarios').value = '';
            
            // Clear all input file uploads and reset their upload zones (including folder fields and Live Locations)
            const allFields = ['infrastructure', 'geometry', 'timetable1', 'timetable2', 'timetableRules', 'possessions', 'speedboards', 'tractiveEffort', 'regions', 'liveLocations'];
            
            allFields.forEach(field => {
                // Clear the file input
                const fileInput = document.getElementById(`${field}File`);
                if (fileInput) {
                    fileInput.value = '';
                }
                
                // Clear from uploadedFiles object
                if (uploadedFiles[field]) {
                    delete uploadedFiles[field];
                    console.log(`Cleared ${field} from uploadedFiles`);
                }
                
                // Reset the upload zone state to initial uncolored state
                const uploadZone = document.querySelector(`[data-field="${field}"]`);
                if (uploadZone) {
                    // Remove ALL state classes including blue "ready" state
                    uploadZone.classList.remove('upload-loaded', 'upload-ready', 'upload-pending', 'upload-success', 'upload-error', 'has-file', 'uploading', 'error');
                    
                    const uploadIcon = uploadZone.querySelector('.upload-icon');
                    const uploadText = uploadZone.querySelector('.upload-text');
                    const clearBtn = uploadZone.querySelector('.clear-btn');
                    
                    // Reset to initial uncolored state
                    if (uploadIcon) {
                        const isFolder = field === 'geometry' || field === 'tractiveEffort';
                        uploadIcon.textContent = isFolder ? 'üìÅ' : 'üìÑ';
                    }
                    
                    if (uploadText) {
                        uploadText.style.color = ''; // Clear inline color
                        uploadText.classList.remove('file-info');
                        const isFolder = field === 'geometry' || field === 'tractiveEffort';
                        if (field === 'liveLocations') {
                            uploadText.textContent = 'Drop Live Locations file here or click to browse';
                        } else {
                            uploadText.textContent = isFolder ? 'Click or drag folder here' : 'Click or drag CSV file here';
                        }
                    }
                    
                    if (clearBtn) {
                        clearBtn.style.display = 'none';
                    }
                }
            });
            
            addOutput('Cleared all inputs for new scenario', 'info');
        }
        
        async function duplicateScenario() {
            const selectedScenario = document.getElementById('existingScenarios').value;
            const newName = document.getElementById('newScenarioName').value;
            
            if (!selectedScenario) {
                addOutput('Please select a scenario to duplicate', 'error');
                return;
            }
            
            if (!newName) {
                addOutput('Please enter a name for the duplicated scenario', 'error');
                return;
            }
            
            const userName = document.getElementById('userName').value.trim();
            if (!userName) {
                addOutput('Please enter your username', 'error');
                return;
            }
            
            try {
                // First load the selected scenario
                const loadResponse = await fetch(`${serverUrl}/api/scenario/load`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        name: selectedScenario, 
                        userName,
                        scenarioPath: document.getElementById('scenarioPath').value
                    })
                });
                
                const loadResult = await loadResponse.json();
                if (!loadResult.success) {
                    addOutput(`Failed to load original scenario: ${loadResult.error}`, 'error');
                    return;
                }
                
                // Save with new name
                const saveResponse = await fetch(`${serverUrl}/api/scenario/create`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        name: newName, 
                        data: loadResult.data, 
                        userName,
                        scenarioPath: document.getElementById('scenarioPath').value,


                    })
                });
                
                const saveResult = await saveResponse.json();
                if (saveResult.success) {
                    addOutput(`Duplicated scenario '${selectedScenario}' as '${newName}'`, 'info');
                    refreshExistingScenarios();
                    document.getElementById('newScenarioName').value = '';
                } else {
                    addOutput(`Failed to duplicate scenario: ${saveResult.error}`, 'error');
                }
                
            } catch (error) {
                addOutput(`Duplication error: ${error.message}`, 'error');
            }
        }
        
        function handleDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }
        

        

        

        
        // User File and Directory Browsing Functions
        async function browseUserFile(fieldId) {
            const userName = document.getElementById('userName').value.trim();
            if (!userName) {
                addOutput('Please enter your username first', 'error');
                return;
            }
            
            try {
                const response = await fetch(`${serverUrl}/api/files/browse`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        userName: userName,
                        type: 'file'
                    })
                });
                
                const result = await response.json();
                if (result.success && result.files.length > 0) {
                    showFilePicker(fieldId, result.files, 'Select a file:');
                } else {
                    addOutput('No files found in your directory. Upload some files first.', 'info');
                }
            } catch (error) {
                addOutput(`Error browsing files: ${error.message}`, 'error');
            }
        }
        
        async function browseUserDirectory(fieldId) {
            const userName = document.getElementById('userName').value.trim();
            if (!userName) {
                addOutput('Please enter your username first', 'error');
                return;
            }
            
            // Use current upload path as starting point, or default to user directory
            const currentPath = document.getElementById('uploadPath').value.trim();
            const startPath = currentPath || `/opt/traxim/input-data/${userName}/`;
            
            browseDirectory(fieldId, startPath, 'Select a directory:');
        }
        
        async function browseDirectory(fieldId, browsePath, title) {
            try {
                const response = await fetch(`${serverUrl}/api/files/browse`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        path: browsePath,
                        type: 'directory'
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    const directories = result.directories || [];
                    showFilePicker(fieldId, directories, title, true, browsePath);
                } else {
                    addOutput(`Error browsing directories: ${result.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                addOutput(`Error browsing directories: ${error.message}`, 'error');
            }
        }
        
        // Global variables for file picker
        let currentFieldId = '';
        let currentItems = [];
        let currentIsDirectory = false;
        let selectedFileIndex = -1;
        let currentBrowsePath = '';
        
        function showFilePicker(fieldId, items, title, isDirectory = false, currentPath = '') {
            currentBrowsePath = currentPath;
            currentFieldId = fieldId;
            currentItems = items;
            currentIsDirectory = isDirectory;
            selectedFileIndex = -1;
            
            // Filter CSV files for file pickers (not for directories)
            if (!isDirectory) {
                currentItems = items.filter(item => item.toLowerCase().endsWith('.csv'));
            }
            
            // Update modal title
            document.querySelector('.file-picker-title').textContent = title;
            
            // Populate file list
            const fileList = document.getElementById('fileList');
            const emptyState = document.getElementById('emptyState');
            
            fileList.innerHTML = '';
            
            if (currentItems.length === 0) {
                fileList.style.display = 'none';
                emptyState.style.display = 'block';
            } else {
                fileList.style.display = 'block';
                emptyState.style.display = 'none';
                
                // Track if we added a parent directory (affects indexing)
                let hasParentDir = false;
                
                // Add parent directory option if not at root
                if (isDirectory && currentBrowsePath && currentBrowsePath !== '/opt/traxim/input-data/' && !currentBrowsePath.endsWith('/input-data/')) {
                    const parentLi = document.createElement('li');
                    parentLi.className = 'file-item parent-dir';
                    parentLi.onclick = () => navigateToParent();
                    parentLi.innerHTML = `
                        <span class="file-icon">‚¨ÜÔ∏è</span>
                        <span class="file-name">..</span>
                    `;
                    fileList.appendChild(parentLi);
                    hasParentDir = true;
                }
                
                currentItems.forEach((item, index) => {
                    const li = document.createElement('li');
                    li.className = 'file-item';
                    // Use the actual DOM index for selection
                    const domIndex = hasParentDir ? index + 1 : index;
                    li.onclick = () => selectFileItem(domIndex, index);
                    
                    // Add double-click navigation for directories
                    if (isDirectory) {
                        li.ondblclick = () => navigateToDirectory(item);
                    }
                    
                    const icon = isDirectory ? 'üìÅ' : 'üìÑ';
                    li.innerHTML = `
                        <span class="file-icon">${icon}</span>
                        <span class="file-name">${item}</span>
                    `;
                    
                    fileList.appendChild(li);
                });
            }
            
            // Reset and show modal
            document.getElementById('selectFileBtn').disabled = true;
            document.getElementById('filePickerModal').style.display = 'block';
        }
        
        function selectFileItem(domIndex, arrayIndex) {
            // Remove previous selection
            document.querySelectorAll('.file-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            // Select new item using DOM index
            const fileItems = document.querySelectorAll('.file-item');
            if (fileItems[domIndex]) {
                fileItems[domIndex].classList.add('selected');
                // Store the array index for the actual file selection
                selectedFileIndex = arrayIndex;
                document.getElementById('selectFileBtn').disabled = false;
            }
        }
        
        function navigateToParent() {
            if (currentBrowsePath) {
                // Remove trailing slash and get parent directory
                const trimmedPath = currentBrowsePath.replace(/\/$/, '');
                const parentPath = trimmedPath.substring(0, trimmedPath.lastIndexOf('/')) + '/';
                browseDirectory(currentFieldId, parentPath, 'Select a directory:');
            }
        }
        
        function navigateToDirectory(dirName) {
            if (currentBrowsePath && dirName) {
                const newPath = currentBrowsePath.endsWith('/') ? 
                    currentBrowsePath + dirName + '/' : 
                    currentBrowsePath + '/' + dirName + '/';
                browseDirectory(currentFieldId, newPath, 'Select a directory:');
            }
        }
        
        function selectFile() {
            if (selectedFileIndex >= 0 && selectedFileIndex < currentItems.length) {
                const selectedItem = currentItems[selectedFileIndex];
                
                // Use the current browse path and append the selected item
                let fullPath;
                if (currentBrowsePath) {
                    // Ensure current path ends with slash, then append selected item
                    const basePath = currentBrowsePath.endsWith('/') ? currentBrowsePath : currentBrowsePath + '/';
                    fullPath = basePath + selectedItem;
                    if (currentIsDirectory) {
                        fullPath += '/'; // Add trailing slash for directories
                    }
                } else {
                    // Fallback to old behavior if no current path
                    const userName = document.getElementById('userName').value.trim();
                    fullPath = `/opt/traxim/input-data/${userName}/${selectedItem}`;
                    if (currentIsDirectory) {
                        fullPath += '/';
                    }
                }
                
                document.getElementById(currentFieldId).value = fullPath;
                addOutput(`Selected ${currentIsDirectory ? 'directory' : 'file'}: ${fullPath}`, 'success');
                
                closeFilePicker();
            }
        }
        
        function closeFilePicker() {
            document.getElementById('filePickerModal').style.display = 'none';
            selectedFileIndex = -1;
            currentFieldId = '';
            currentItems = [];
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('filePickerModal');
            const downloadModal = document.getElementById('downloadPickerModal');
            if (event.target === modal) {
                closeFilePicker();
            }
            if (event.target === downloadModal) {
                closeDownloadPicker();
            }
        }
        
        // Download Picker Functions
        async function openDownloadPicker() {
            const outputsFolder = document.getElementById('outputsFolder').value.trim();
            if (!outputsFolder) {
                await showCustomAlert('No Outputs Folder', 'Please select an outputs folder first.');
                return;
            }
            
            document.getElementById('downloadPickerModal').style.display = 'flex';
            loadDownloadFiles(outputsFolder);
        }
        
        function closeDownloadPicker() {
            document.getElementById('downloadPickerModal').style.display = 'none';
        }
        
        async function loadDownloadFiles(folderPath) {
            try {
                const userName = document.getElementById('userName').value.trim();
                if (!userName) {
                    throw new Error('Please enter a username first.');
                }
                
                console.log('Loading download files from path:', folderPath);
                console.log('Username:', userName);
                console.log('Using server URL:', serverUrl);
                
                const response = await fetch(`${serverUrl}/api/files/browse?path=${encodeURIComponent(folderPath)}&username=${encodeURIComponent(userName)}`);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server response:', errorText);
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Server returned data:', data);
                
                if (!data.success) {
                    throw new Error(data.error || 'Server returned error');
                }
                
                populateDownloadFileList(data.files);
            } catch (error) {
                console.error('Error loading download files:', error);
                // Show the actual error message in the empty state
                const emptyState = document.getElementById('downloadEmptyState');
                emptyState.innerHTML = `
                    <div>üìÅ</div>
                    <p>Error loading files: ${error.message}</p>
                    <p>Check the console for more details.</p>
                `;
                emptyState.style.display = 'block';
                document.getElementById('downloadFileList').style.display = 'none';
            }
        }
        
        function populateDownloadFileList(files) {
            const fileList = document.getElementById('downloadFileList');
            const emptyState = document.getElementById('downloadEmptyState');
            
            fileList.innerHTML = '';
            
            if (!files || files.length === 0) {
                fileList.style.display = 'none';
                emptyState.style.display = 'block';
                return;
            }
            
            emptyState.style.display = 'none';
            fileList.style.display = 'block';
            
            files.forEach((file, index) => {
                const li = document.createElement('li');
                li.className = 'file-item';
                li.innerHTML = `
                    <input type="checkbox" id="download_${index}" onchange="updateDownloadButton()">
                    <span class="file-icon">${file.isDirectory ? 'üìÅ' : 'üìÑ'}</span>
                    <span class="file-name">${file.name}</span>
                `;
                fileList.appendChild(li);
            });
            
            updateDownloadButton();
        }
        
        function updateDownloadButton() {
            const checkboxes = document.querySelectorAll('#downloadFileList input[type="checkbox"]');
            const hasSelected = Array.from(checkboxes).some(cb => cb.checked);
            document.getElementById('downloadSelectedBtn').disabled = !hasSelected;
        }
        
        async function downloadSelectedFiles() {
            const checkboxes = document.querySelectorAll('#downloadFileList input[type="checkbox"]:checked');
            const selectedFiles = [];
            
            checkboxes.forEach((checkbox, index) => {
                const fileName = checkbox.parentElement.querySelector('.file-name').textContent;
                selectedFiles.push(fileName);
            });
            
            if (selectedFiles.length === 0) {
                await showCustomAlert('No Files Selected', 'Please select files to download.');
                return;
            }
            
            // Download each selected file
            for (const fileName of selectedFiles) {
                await downloadFile(fileName);
            }
            
            closeDownloadPicker();
        }
        
        async function downloadFile(fileName) {
            try {
                const outputsFolder = document.getElementById('outputsFolder').value.trim();
                const userName = document.getElementById('userName').value.trim();
                const filePath = `${outputsFolder}/${fileName}`;
                
                console.log('Downloading file:', fileName, 'from path:', filePath);
                const response = await fetch(`${serverUrl}/api/files/download?path=${encodeURIComponent(filePath)}&username=${encodeURIComponent(userName)}`);
                if (!response.ok) {
                    throw new Error(`Failed to download ${fileName}`);
                }
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (error) {
                console.error(`Error downloading ${fileName}:`, error);
                alert(`Failed to download ${fileName}`);
            }
        }
        
        // Update outputs folder for new scenarios being created with uploads
        function updateOutputsForNewScenario() {
            const userName = document.getElementById('userName').value.trim();
            const sessionId = window.uploadSession;
            
            if (userName && sessionId) {
                const outputPath = `/opt/traxim/input-data/${userName.toLowerCase()}/session_${sessionId}/outputs/`;
                document.getElementById('outputsFolder').value = outputPath;
                console.log('Updated outputs folder for new scenario:', outputPath);
            }
        }
        
        // Update outputs folder from XML scenario data
        function updateOutputsFolderFromScenario(xmlDoc) {
            const userName = document.getElementById('userName').value.trim();
            if (!userName) return;
            
            // Check for session-based paths in the scenario
            const infrastructurePath = xmlDoc.querySelector('Infrastructure')?.textContent || '';
            const sessionMatch = infrastructurePath.match(/session_([a-zA-Z0-9]+)/);
            
            let outputPath;
            if (sessionMatch) {
                // Session-based scenario - outputs go in the session folder
                const sessionId = sessionMatch[1];
                outputPath = `/opt/traxim/input-data/${userName.toLowerCase()}/session_${sessionId}/outputs/`;
                console.log('XML: Session-based scenario detected, outputs path:', outputPath);
            } else {
                // Legacy scenario - try to determine from scenario file name
                const scenarioFile = document.getElementById('scenarioFile').value;
                if (scenarioFile) {
                    const scenarioName = scenarioFile.replace('.scn', '');
                    outputPath = `/opt/traxim/input-data/${userName.toLowerCase()}/${scenarioName}/outputs/`;
                    console.log('XML: Legacy scenario detected, outputs path:', outputPath);
                } else {
                    outputPath = `/opt/traxim/input-data/${userName.toLowerCase()}/outputs/`;
                    console.log('XML: Default outputs path:', outputPath);
                }
            }
            
            document.getElementById('outputsFolder').value = outputPath;
        }
        
        // Update outputs folder from JSON scenario data
        function updateOutputsFolderFromScenarioData(data) {
            const userName = document.getElementById('userName').value.trim();
            if (!userName) return;
            
            // Helper function to get value with multiple possible property names
            const getValue = (data, ...keys) => {
                for (const key of keys) {
                    if (data[key] !== undefined && data[key] !== null) {
                        return data[key];
                    }
                }
                return '';
            };
            
            // Check for session-based paths in the scenario data
            const infrastructurePath = getValue(data, 'infrastructure', 'Infrastructure');
            const sessionMatch = infrastructurePath.match(/session_([a-zA-Z0-9]+)/);
            
            let outputPath;
            if (sessionMatch) {
                // Session-based scenario
                const sessionId = sessionMatch[1];
                outputPath = `/opt/traxim/input-data/${userName.toLowerCase()}/session_${sessionId}/outputs/`;
                console.log('JSON: Session-based scenario detected, outputs path:', outputPath);
            } else {
                // Legacy scenario - try to determine from scenario file name
                const scenarioFile = document.getElementById('scenarioFile').value;
                if (scenarioFile) {
                    const scenarioName = scenarioFile.replace('.scn', '');
                    outputPath = `/opt/traxim/input-data/${userName.toLowerCase()}/${scenarioName}/outputs/`;
                    console.log('JSON: Legacy scenario detected, outputs path:', outputPath);
                } else {
                    outputPath = `/opt/traxim/input-data/${userName.toLowerCase()}/outputs/`;
                    console.log('JSON: Default outputs path:', outputPath);
                }
            }
            
            document.getElementById('outputsFolder').value = outputPath;
        }
        
        // Update upload zones to show what files are referenced in a loaded scenario
        async function updateUploadZonesFromLoadedScenario(filePaths) {
            console.log('Updating upload zones with loaded scenario file paths:', filePaths);
            
            // Define field mapping between scenario elements and upload zones
            const fieldMapping = {
                infrastructure: 'infrastructure',
                geometry: 'geometry', 
                timetable1: 'timetable1',
                timetable2: 'timetable2',
                timetableRules: 'timetableRules',
                possessions: 'possessions',
                speedboards: 'speedboards',
                tractiveEffort: 'tractiveEffort',
                regions: 'regions',
                liveLocations: 'liveLocations'
            };
            
            // Reference original files without copying (copying will happen at save time if needed)
            const userName = document.getElementById('userName').value.trim();
            console.log('Referencing original scenario files without copying (will copy at save time if needed)');
            
            // Update each upload zone based on loaded scenario
            Object.keys(fieldMapping).forEach(scenarioField => {
                const fieldName = fieldMapping[scenarioField];
                const originalPath = filePaths[scenarioField];
                
                if (originalPath && originalPath.trim()) {
                    // Convert relative paths to absolute paths based on current user
                    const userDir = `/opt/traxim/input-data/${userName.toLowerCase()}/`;
                    let absolutePath;
                    if (originalPath.startsWith('/')) {
                        absolutePath = originalPath;
                    } else {
                        absolutePath = userDir + originalPath;
                    }
                    
                    const displayName = originalPath.split('/').pop() || originalPath;
                    console.log(`Referencing original file for ${fieldName}: ${originalPath} -> ${absolutePath}`);
                    
                    // IMPORTANT: Add the file path to uploadedFiles object so it can be used in scenario generation
                    uploadedFiles[fieldName] = {
                        fileName: displayName,
                        filePath: absolutePath,
                        type: (fieldName === 'geometry' || fieldName === 'tractiveEffort') ? 'folder' : 'file',
                        source: 'referenced' // Mark as referenced from original location
                    };
                    
                    // Update the upload zone to show "loaded from scenario" in green (modified/unsaved state)
                    const zone = document.querySelector(`[data-field="${fieldName}"]`);
                    if (zone) {
                        zone.classList.remove('upload-pending', 'upload-success', 'upload-error', 'upload-loaded', 'upload-ready');
                        zone.classList.add('has-file'); // Show as having a file but not saved yet
                        
                        const uploadIcon = zone.querySelector('.upload-icon');
                        if (uploadIcon) {
                            uploadIcon.textContent = '‚úÖ';
                        }
                        
                        const uploadText = zone.querySelector('.upload-text');
                        if (uploadText) {
                            uploadText.textContent = `Loaded: ${displayName}`;
                            uploadText.classList.add('file-info');
                            uploadText.style.color = '#43a047'; // Green color for loaded but unsaved files
                        }
                        
                        // Show Clear button for optional files that have been loaded
                        const clearBtn = zone.querySelector('.clear-btn');
                        if (clearBtn && ['timetable2', 'possessions', 'liveLocations'].includes(fieldName)) {
                            clearBtn.style.display = 'inline-block';
                        }
                        
                        console.log(`Updated ${fieldName} zone with loaded file: ${displayName} (shown in green as unsaved)`);
                    }
                } else {
                    // Clear the upload zone if no file is specified
                    const zone = document.querySelector(`[data-field="${fieldName}"]`);
                    if (zone) {
                        zone.classList.remove('upload-pending', 'upload-success', 'upload-error', 'upload-loaded');
                        
                        const uploadText = zone.querySelector('.upload-text');
                        if (uploadText) {
                            // Set appropriate text based on field type
                            const isFolderField = fieldName === 'geometry' || fieldName === 'tractiveEffort';
                            uploadText.textContent = isFolderField ? 'Click or drag folder here' : 'Click or drag CSV file here';
                            uploadText.style.color = '';
                        }
                    }
                }
            });
        }
        
        async function aggregateResults() {
            if (isRunning) {
                addOutput('Program is already running', 'error');
                return;
            }

            const outputsFolder = document.getElementById('outputsFolder').value.trim();
            const userName = document.getElementById('userName').value.trim();
            const executablePath = document.getElementById('executablePath').value;

            if (!outputsFolder) {
                addOutput('Please specify an outputs folder first', 'error');
                return;
            }

            if (!userName) {
                addOutput('Please enter your username first', 'error');
                return;
            }

            if (!executablePath) {
                addOutput('Please specify the executable path', 'error');
                return;
            }

            setStatus('running', 'Aggregating results...');
            isRunning = true;

            try {
                addOutput('Step 1: Finding .detail files in outputs folder...', 'info');

                // Get list of .detail files from the outputs folder
                const browseResponse = await fetch(`${serverUrl}/api/files/browse`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        path: outputsFolder,
                        type: 'file'
                    })
                });

                const browseResult = await browseResponse.json();
                if (!browseResult.success) {
                    addOutput(`Failed to browse outputs folder: ${browseResult.error}`, 'error');
                    setStatus('error', 'Failed to browse outputs folder');
                    isRunning = false;
                    return;
                }

                // Filter for .detail files
                const detailFiles = browseResult.files.filter(file => 
                    file.toLowerCase().endsWith('.detail')
                );

                if (detailFiles.length === 0) {
                    addOutput('No .detail files found in outputs folder', 'error');
                    setStatus('error', 'No detail files found');
                    isRunning = false;
                    return;
                }

                addOutput(`Found ${detailFiles.length} .detail file(s)`, 'info');

                // Helper function to escape XML special characters
                const escapeXml = (text) => {
                    return text
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&apos;');
                };

                // Generate Aggregate.xml content
                const now = new Date();
                const timestamp = `${now.getDate()}/${now.getMonth() + 1}/${now.getFullYear()} @ ${now.getHours()}:${now.getMinutes()}`;
                
                let xmlContent = `<?xml version="1.0" encoding="utf-8"?>
<Traxim Version="5.0.0.0" SettingsVersion="1" WrittenAt="${timestamp}">
  <!--TraximWeb by Derek Harris, James Moor, Stuart Mau.-->
  <AggregatorSettings>
    <ResultsDirectory>${escapeXml(outputsFolder)}</ResultsDirectory>
`;

                // Add each detail file
                detailFiles.forEach(file => {
                    xmlContent += `    <DetailFile>\\${escapeXml(file)}</DetailFile>\n`;
                });

                xmlContent += `  </AggregatorSettings>
</Traxim>`;

                addOutput('Step 2: Creating Aggregate.xml file...', 'info');

                // Save Aggregate.xml to the outputs folder
                const saveResponse = await fetch(`${serverUrl}/api/file/write`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filePath: `${outputsFolder}/Aggregate.xml`,
                        content: xmlContent,
                        userName: userName
                    })
                });

                const saveResult = await saveResponse.json();
                if (!saveResult.success) {
                    addOutput(`Failed to create Aggregate.xml: ${saveResult.error}`, 'error');
                    setStatus('error', 'Failed to create Aggregate.xml');
                    isRunning = false;
                    return;
                }

                addOutput('Aggregate.xml created successfully', 'success');
                addOutput('Step 3: Running aggregation...', 'info');

                // Run the aggregation command
                const aggregatePath = `${outputsFolder}/Aggregate.xml`;
                addOutput(`Running: ${executablePath} local --project "${aggregatePath}" --aggregate`, 'info');

                const runResponse = await fetch(`${serverUrl}/api/run`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        executable: executablePath,
                        scenario: aggregatePath,
                        aggregate: true
                    })
                });

                if (!runResponse.ok) {
                    throw new Error(`HTTP error! status: ${runResponse.status}`);
                }

                // Read streaming response (SSE format)
                const reader = runResponse.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let finalResult = null;
                
                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';
                        
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.slice(6));
                                    
                                    if (data.type === 'stdout' && data.data) {
                                        addOutput(data.data, 'info');
                                    } else if (data.type === 'stderr' && data.data) {
                                        addOutput(data.data, 'error');
                                    } else if (data.type === 'complete') {
                                        finalResult = data;
                                        addOutput('Aggregation process completed', 'success');
                                    } else if (data.type === 'error') {
                                        addOutput(`Aggregation Error: ${data.error}`, 'error');
                                        finalResult = data;
                                    }
                                } catch (parseError) {
                                    console.error('Error parsing SSE data:', parseError, 'Line:', line);
                                }
                            }
                        }
                    }
                } catch (readError) {
                    console.error('Error reading aggregation stream:', readError);
                    addOutput(`Stream error: ${readError.message}`, 'error');
                } finally {
                    reader.releaseLock();
                }

                // Check final result
                if (finalResult && finalResult.type === 'complete') {
                    setStatus('success', 'Aggregation completed successfully');
                } else if (finalResult && finalResult.type === 'error') {
                    setStatus('error', 'Aggregation failed');
                } else {
                    setStatus('idle', 'Aggregation process finished');
                }

            } catch (error) {
                addOutput(`Aggregation failed: ${error.message}`, 'error');
                setStatus('error', 'Aggregation failed');
            } finally {
                isRunning = false;
                setTimeout(() => {
                    if (!autoScheduleInterval) {
                        setStatus('idle', 'System Ready');
                    }
                }, 3000);
            }
        }
        
        // Update outputs folder when scenario file changes
        async function updateOutputsFolder() {
            const scenarioFile = document.getElementById('scenarioFile').value;
            const userName = document.getElementById('userName').value.trim();
            
            console.log('=== updateOutputsFolder called ===');
            console.log('scenarioFile:', scenarioFile);
            console.log('userName:', userName);
            
            if (scenarioFile && userName) {
                console.log('Updating outputs folder for scenario:', scenarioFile);
                
                try {
                    // For session-based scenarios, determine outputs path from the scenario file
                    const scenarioPath = document.getElementById('scenarioPath').value;
                    console.log('scenarioPath:', scenarioPath);
                    
                    // Load the scenario file to extract session information
                    console.log('Making API call to load scenario...');
                    const response = await fetch(`${serverUrl}/api/scenario/load`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            name: scenarioFile, 
                            userName: userName,
                            scenarioPath 
                        })
                    });
                    
                    console.log('API response status:', response.status, response.ok);
                    
                    if (response.ok) {
                        console.log('API call successful, parsing response...');
                        const data = await response.json();
                        console.log('API response data:', data);
                        
                        if (data.success && data.data) {
                            console.log('Data has success and data, processing...');
                            // Try to determine if this is a session-based scenario by looking at file paths
                            const content = typeof data.data === 'string' ? data.data : JSON.stringify(data.data);
                            console.log('Content sample:', content.substring(0, 200));
                            const sessionMatch = content.match(/session_([a-zA-Z0-9]+)/);
                            console.log('Session match result:', sessionMatch);
                            
                            let outputPath;
                            if (sessionMatch) {
                                // Session-based scenario - outputs go in the session folder
                                const sessionId = sessionMatch[1];
                                outputPath = `/opt/traxim/input-data/${userName.toLowerCase()}/session_${sessionId}/outputs/`;
                                console.log('Session-based scenario detected, outputs path:', outputPath);
                            } else {
                                // Legacy scenario - outputs go in scenario-specific folder
                                const scenarioName = scenarioFile.replace('.scn', '');
                                outputPath = `/opt/traxim/input-data/${userName.toLowerCase()}/${scenarioName}/outputs/`;
                                console.log('Legacy scenario detected, outputs path:', outputPath);
                            }
                            
                            document.getElementById('outputsFolder').value = outputPath;
                            console.log('Set outputsFolder value to:', outputPath);
                        } else {
                            console.log('API response missing success or data:', { success: data.success, hasData: !!data.data });
                        }
                    } else {
                        console.log('API call failed with status:', response.status);
                        console.log('Failed to load scenario file, using fallback path');
                        const scenarioDir = document.getElementById('scenarioPath').value;
                        document.getElementById('outputsFolder').value = scenarioDir;
                        console.log('Set fallback outputsFolder to:', scenarioDir);
                    }
                } catch (error) {
                    console.error('Error loading scenario for outputs path:', error);
                    console.error('Error details:', error.message, error.stack);
                    // Fallback to scenario directory
                    const scenarioDir = document.getElementById('scenarioPath').value;
                    document.getElementById('outputsFolder').value = scenarioDir;
                    console.log('Set error fallback outputsFolder to:', scenarioDir);
                }
            } else {
                // Clear outputs folder if no scenario is selected
                document.getElementById('outputsFolder').value = '';
            }
        }
        
        // Update session ID when scenario file changes in dropdown
        function updateSessionId() {
            const scenarioFile = document.getElementById('scenarioFile').value;
            
            if (scenarioFile) {
                // Clear uploadSession since we're selecting from existing scenarios
                window.uploadSession = null;
                // Update currentSessionId to match selected scenario
                window.currentSessionId = scenarioFile.replace('.scn', '');
                console.log('[SESSION] Dropdown change - Updated sessionId to:', window.currentSessionId);
            } else {
                window.currentSessionId = 'default';
                console.log('[SESSION] Dropdown cleared - sessionId reset to default');
            }
        }
        
        // Session Cleanup Functions
        let cleanupInterval = null;
        
        function startSessionCleanup() {
            // Run cleanup every 30 minutes (1800000 ms)
            cleanupInterval = setInterval(cleanupOrphanedSessions, 30 * 60 * 1000);
            
            // Also run once on startup (after 30 seconds to let page fully load)
            setTimeout(cleanupOrphanedSessions, 30000);
            
            console.log('Session cleanup started - will run every 30 minutes');
        }
        
        function stopSessionCleanup() {
            if (cleanupInterval) {
                clearInterval(cleanupInterval);
                cleanupInterval = null;
                console.log('Session cleanup stopped');
            }
        }
        
        async function cleanupOrphanedSessions() {
            try {
                const userName = document.getElementById('userName').value.trim();
                if (!userName) {
                    console.log('Session cleanup skipped - no username set');
                    return;
                }
                
                console.log('Starting orphaned session cleanup...');
                
                const response = await fetch(`${serverUrl}/api/cleanup/orphaned-sessions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userName })
                });
                
                const result = await response.json();
                if (result.success) {
                    if (result.deletedSessions && result.deletedSessions.length > 0) {
                        console.log(`Cleaned up ${result.deletedSessions.length} orphaned sessions:`, result.deletedSessions);
                        addOutput(`Cleaned up ${result.deletedSessions.length} orphaned session(s)`, 'info');
                    } else {
                        console.log('No orphaned sessions found');
                    }
                } else {
                    console.error('Session cleanup failed:', result.error);
                }
            } catch (error) {
                console.error('Session cleanup error:', error);
            }
        }
        
        // Manual cleanup function for testing/admin use
        async function manualSessionCleanup() {
            await cleanupOrphanedSessions();
        }
        
        // File Upload Functions for Input Files
        let uploadedFiles = {}; // Store uploaded files by field name
        // Session will be created on first upload or setting change
        window.uploadSession = null;
        
        // Synchronous wrapper for HTML onchange handlers
        function ensureSessionExistsSync() {
            // If we have uploaded files (from a loaded scenario or previous uploads), 
            // create a new session to track this modification
            const hasFiles = Object.keys(uploadedFiles).length > 0;
            
            // Force new session if we have files, regardless of whether a session exists
            // This handles both: (1) first change after loading scenario, (2) re-modification of existing session
            const forceNew = hasFiles;
            
            console.log('ensureSessionExistsSync called - hasFiles:', hasFiles, 'forceNew:', forceNew, 'currentSession:', window.uploadSession);
            
            ensureSessionExists(forceNew).catch(error => {
                console.error('Error ensuring session exists:', error);
            });
        }
        
        // Helper function to ensure a session exists for any changes
        async function ensureSessionExists(forceNewSession = false) {
            const oldSession = window.uploadSession;
            const hasFiles = Object.keys(uploadedFiles).length > 0;
            
            console.log('ensureSessionExists called - forceNewSession:', forceNewSession, 'oldSession:', oldSession, 'hasFiles:', hasFiles);
            
            // Create new session if:
            // 1. No session exists yet (initial creation), OR
            // 2. Forcing new session AND we have files to copy
            const shouldCreateSession = !window.uploadSession || (forceNewSession && hasFiles);
            
            if (shouldCreateSession) {
                window.uploadSession = Math.random().toString(36).substr(2, 9);
                
                if (forceNewSession && oldSession) {
                    addOutput(`Creating new session for modifications: ${window.uploadSession}`, 'info');
                } else if (forceNewSession && !oldSession && hasFiles) {
                    addOutput(`Creating new session from loaded scenario: ${window.uploadSession}`, 'info');
                } else {
                    addOutput(`Created new session: ${window.uploadSession}`, 'info');
                }
                
                // Create session directory on server
                const userName = document.getElementById('userName').value.trim();
                if (userName) {
                    try {
                        // Prepare list of files to copy if we have referenced files but no old session
                        let filesToCopy = [];
                        if (forceNewSession && !oldSession && hasFiles) {
                            // We have files from a loaded scenario - tell server which files to copy
                            Object.keys(uploadedFiles).forEach(fieldName => {
                                const fileInfo = uploadedFiles[fieldName];
                                if (fileInfo.filePath || fileInfo.folderPath) {
                                    filesToCopy.push({
                                        fieldName: fieldName,
                                        sourcePath: fileInfo.filePath || fileInfo.folderPath,
                                        type: fileInfo.type || 'file'
                                    });
                                }
                            });
                            console.log('Files to copy from loaded scenario:', filesToCopy);
                        }
                        
                        const response = await fetch(`${serverUrl}/api/session/create`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                sessionId: window.uploadSession, 
                                userName: userName,
                                copyFromSession: (forceNewSession && oldSession) ? oldSession : null,
                                filesToCopy: filesToCopy.length > 0 ? filesToCopy : undefined
                            })
                        });
                        
                        const result = await response.json();
                        if (result.success) {
                            console.log(`Session directory created: ${result.sessionPath}`);
                            if (result.copiedFiles && result.copiedFiles.length > 0) {
                                addOutput(`Copied ${result.copiedFiles.length} existing files to new session`, 'info');
                            }
                            
                            // If this was a forced new session with files, update all uploadedFiles paths and UI
                            if (forceNewSession && hasFiles) {
                                console.log('Calling updateUploadedFilePathsForNewSession...');
                                updateUploadedFilePathsForNewSession(result.sessionPath, result.copiedFiles);
                            }
                        } else {
                            console.warn(`Failed to create session directory: ${result.error}`);
                        }
                    } catch (error) {
                        console.warn(`Error creating session directory: ${error.message}`);
                    }
                }
                
                updateOutputsForNewScenario(); // Update outputs folder for the new session
            }
        }
        
        // Helper function to update uploadedFiles paths and UI when files are copied to a new session
        function updateUploadedFilePathsForNewSession(newSessionPath, copiedFiles) {
            console.log('=== updateUploadedFilePathsForNewSession START ===');
            console.log('newSessionPath:', newSessionPath);
            console.log('copiedFiles:', copiedFiles);
            console.log('Current uploadedFiles:', JSON.parse(JSON.stringify(uploadedFiles)));
            
            const userName = document.getElementById('userName').value.trim().toLowerCase();
            const sessionId = window.uploadSession;
            
            // Update each field that has an uploaded file
            Object.keys(uploadedFiles).forEach(fieldName => {
                const fileInfo = uploadedFiles[fieldName];
                console.log(`Processing field: ${fieldName}`, fileInfo);
                
                // Update the file path to point to the new session
                if (fileInfo.filePath) {
                    // Extract just the filename from the old path
                    const fileName = fileInfo.filePath.split('/').pop();
                    console.log(`  Original path: ${fileInfo.filePath}`);
                    console.log(`  Extracted filename: ${fileName}`);
                    
                    // Create new path in the new session
                    // NOTE: Server adds fieldName prefix to files, so we need to include it
                    let newPath;
                    if (fieldName === 'liveLocations') {
                        // Live Locations goes in outputs subfolder without prefix
                        newPath = `/opt/traxim/input-data/${userName}/session_${sessionId}/outputs/${fileName}`;
                    } else {
                        // Other files go in session root with field prefix
                        // Check if filename already has the prefix to avoid duplication
                        const prefixedName = fileName.startsWith(`${fieldName}_`) ? fileName : `${fieldName}_${fileName}`;
                        newPath = `/opt/traxim/input-data/${userName}/session_${sessionId}/${prefixedName}`;
                    }
                    
                    fileInfo.filePath = newPath;
                    console.log(`  New path: ${newPath}`);
                } else if (fileInfo.folderPath) {
                    // Update folder path
                    const folderName = fileInfo.folderPath.split('/').filter(p => p).pop();
                    const newPath = `/opt/traxim/input-data/${userName}/session_${sessionId}/${folderName}`;
                    fileInfo.folderPath = newPath;
                    console.log(`  Updated folder ${fieldName} path to: ${newPath}`);
                }
                
                // Update UI to show green (modified/unsaved state)
                const zone = document.querySelector(`[data-field="${fieldName}"]`);
                if (zone) {
                    // Remove blue "ready" class and add green "modified" styling
                    zone.classList.remove('upload-loaded', 'upload-ready');
                    zone.classList.add('has-file');
                    
                    const uploadIcon = zone.querySelector('.upload-icon');
                    if (uploadIcon) {
                        uploadIcon.textContent = '‚úÖ';
                    }
                    
                    const uploadText = zone.querySelector('.upload-text');
                    if (uploadText) {
                        const displayName = fileInfo.fileName || 'files';
                        uploadText.textContent = `Modified: ${displayName}`;
                        uploadText.classList.add('file-info');
                        uploadText.style.color = '#43a047'; // Green color for modified files
                    }
                    
                    const clearBtn = zone.querySelector('.clear-btn');
                    if (clearBtn) {
                        clearBtn.style.display = 'inline-block';
                    }
                    
                    console.log(`  Updated ${fieldName} UI to show modified (green) state`);
                }
            });
            
            console.log('Updated uploadedFiles:', JSON.parse(JSON.stringify(uploadedFiles)));
            console.log('=== updateUploadedFilePathsForNewSession END ===');
        }
        
        function triggerFileUpload(fieldName) {
            document.getElementById(fieldName + 'File').click();
        }
        
        function triggerFolderUpload(fieldName) {
            document.getElementById(fieldName + 'Directory').click();
        }
        
        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'copy';
            event.currentTarget.classList.add('dragover');
        }
        
        function handleDragLeave(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');
        }
        
        function handleFileDrop(event, fieldName) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                handleFileUpload(files[0], fieldName);
            }
        }
        
        function handleFolderDrop(event, fieldName) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');
            
            const items = event.dataTransfer.items;
            const files = [];
            
            // Collect all files from dropped items
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.kind === 'file') {
                    const entry = item.webkitGetAsEntry();
                    if (entry) {
                        traverseFileTree(entry, files).then(() => {
                            if (files.length > 0) {
                                handleFolderUpload(files, fieldName);
                            }
                        });
                    }
                }
            }
        }
        
        function handleFileSelect(event, fieldName) {
            const file = event.target.files[0];
            if (file) {
                handleFileUpload(file, fieldName);
            }
        }
        
        function handleFolderSelect(event, fieldName) {
            const files = Array.from(event.target.files);
            if (files.length > 0) {
                handleFolderUpload(files, fieldName);
            }
        }
        
        async function handleFileUpload(file, fieldName) {
            try {
                // Check if this is a re-upload (file already exists for this field AND session already exists)
                const isReUpload = uploadedFiles[fieldName] && uploadedFiles[fieldName].fileName && window.uploadSession;
                
                if (isReUpload) {
                    // Only create new session if we haven't just created one
                    // Check if the current session already has the old file by looking at the path
                    const currentFilePath = uploadedFiles[fieldName].filePath || uploadedFiles[fieldName].folderPath;
                    const isInCurrentSession = currentFilePath && currentFilePath.includes(`session_${window.uploadSession}`);
                    
                    if (isInCurrentSession) {
                        // File is already in current session, just doing a re-upload within same session
                        // Create new session for this re-upload
                        await ensureSessionExists(true);
                        addOutput(`Re-uploading ${fieldName} - created new session`, 'info');
                    } else {
                        // File is from a different session/location, just ensure we have a session
                        await ensureSessionExists();
                    }
                } else {
                    // First upload or no session - just ensure session exists
                    await ensureSessionExists();
                }
                
                // Update UI to show uploading state
                updateUploadZoneState(fieldName, 'uploading', file.name);
                
                // Create form data for upload
                const formData = new FormData();
                formData.append('file', file);
                formData.append('fieldName', fieldName);
                formData.append('sessionId', window.uploadSession);
                formData.append('userName', document.getElementById('userName').value.trim());
                
                // Special handling for Live Locations - upload to outputs folder
                if (fieldName === 'liveLocations') {
                    formData.append('uploadToOutputs', 'true');
                }
                
                const response = await fetch(`${serverUrl}/api/upload/file`, {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        // Store file info
                        uploadedFiles[fieldName] = {
                            fileName: file.name,
                            filePath: result.filePath,
                            type: 'file'
                        };
                        
                        // Update UI to show success (green for new/modified files)
                        const stateType = isReUpload ? 'modified' : 'success';
                        updateUploadZoneState(fieldName, stateType, file.name);
                        const actionText = isReUpload ? 'Re-uploaded' : 'Uploaded';
                        addOutput(`${actionText} ${file.name} for ${fieldName}`, 'success');
                        
                        // Update outputs folder for new scenario being created
                        updateOutputsForNewScenario();
                    } else {
                        throw new Error(result.error || 'Upload failed');
                    }
                } else {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
            } catch (error) {
                console.error('File upload error:', error);
                updateUploadZoneState(fieldName, 'error', `Upload failed: ${error.message}`);
                addOutput(`Failed to upload file for ${fieldName}: ${error.message}`, 'error');
            }
        }
        
        async function handleFolderUpload(files, fieldName) {
            try {
                // Check if this is a re-upload (folder already exists for this field)
                const isReUpload = uploadedFiles[fieldName] && uploadedFiles[fieldName].fileName;
                
                if (isReUpload) {
                    // Create new session for re-uploads and copy existing files
                    await ensureSessionExists(true);
                    addOutput(`Re-uploading ${fieldName} folder - created new session`, 'info');
                } else {
                    // Create session on first upload if none exists
                    await ensureSessionExists();
                }
                
                // Update UI to show uploading state
                updateUploadZoneState(fieldName, 'uploading', `${files.length} files`);
                
                // Upload all files in the folder
                const formData = new FormData();
                files.forEach((file, index) => {
                    formData.append('files', file);
                });
                formData.append('fieldName', fieldName);
                formData.append('sessionId', window.uploadSession);
                formData.append('userName', document.getElementById('userName').value.trim());
                
                const response = await fetch(`${serverUrl}/api/upload/folder`, {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        // Store folder info
                        uploadedFiles[fieldName] = {
                            fileName: `${files.length} files`,
                            folderPath: result.folderPath,
                            type: 'folder',
                            fileCount: files.length
                        };
                        
                        // Update UI to show success (green for new/modified folders)
                        const stateType = isReUpload ? 'modified' : 'success';
                        updateUploadZoneState(fieldName, stateType, `${files.length} files uploaded`);
                        const actionText = isReUpload ? 'Re-uploaded' : 'Uploaded';
                        addOutput(`${actionText} ${files.length} files for ${fieldName}`, 'success');
                        
                        // Update outputs folder for new scenario being created
                        updateOutputsForNewScenario();
                    } else {
                        throw new Error(result.error || 'Upload failed');
                    }
                } else {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
            } catch (error) {
                console.error('Folder upload error:', error);
                updateUploadZoneState(fieldName, 'error', `Upload failed: ${error.message}`);
                addOutput(`Failed to upload folder for ${fieldName}: ${error.message}`, 'error');
            }
        }
        
        function updateUploadZoneState(fieldName, state, message) {
            const zone = document.querySelector(`[data-field="${fieldName}"]`);
            if (!zone) return;
            
            const icon = zone.querySelector('.upload-icon');
            const text = zone.querySelector('.upload-text');
            const clearBtn = zone.querySelector('.clear-btn');
            
            // Reset classes
            zone.classList.remove('has-file', 'uploading', 'error');
            
            switch (state) {
                case 'uploading':
                    zone.classList.add('uploading');
                    icon.textContent = '‚è≥';
                    text.textContent = `Uploading ${message}...`;
                    if (clearBtn) clearBtn.style.display = 'none';
                    break;
                case 'success':
                    zone.classList.add('has-file');
                    icon.textContent = '‚úÖ';
                    text.textContent = `Uploaded: ${message}`;
                    text.classList.add('file-info');
                    // Show green color for newly uploaded files (modified state)
                    text.style.color = '#43a047';
                    if (clearBtn) clearBtn.style.display = 'inline-block';
                    break;
                case 'modified':
                    zone.classList.add('has-file');
                    icon.textContent = '‚úÖ';
                    text.textContent = `Modified: ${message}`;
                    text.classList.add('file-info');
                    // Show green color for modified files
                    text.style.color = '#43a047';
                    if (clearBtn) clearBtn.style.display = 'inline-block';
                    break;
                case 'error':
                    zone.classList.add('error');
                    icon.textContent = '‚ùå';
                    text.textContent = message;
                    if (clearBtn) clearBtn.style.display = 'none';
                    break;
                default:
                    // Reset to default state
                    const isFolder = fieldName === 'geometry' || fieldName === 'tractiveEffort';
                    icon.textContent = isFolder ? 'üìÅ' : 'üìÑ';
                    if (fieldName === 'liveLocations') {
                        text.textContent = 'Drop Live Locations file here or click to browse';
                    } else {
                        text.textContent = isFolder ? 'Click or drag folder here' : 'Click or drag CSV file here';
                    }
                    text.classList.remove('file-info');
                    if (clearBtn) clearBtn.style.display = 'none';
            }
        }
        
        function clearUploadedFile(fieldName) {
            console.log(`Clearing uploaded file for ${fieldName}`);
            
            // Remove from uploadedFiles tracking
            if (uploadedFiles[fieldName]) {
                delete uploadedFiles[fieldName];
                console.log(`Removed ${fieldName} from uploadedFiles object`);
            }
            
            // Clear the file input
            const fileInput = document.getElementById(`${fieldName}File`);
            if (fileInput) {
                fileInput.value = '';
            }
            
            // Get the upload zone and fully reset it
            const zone = document.querySelector(`[data-field="${fieldName}"]`);
            if (zone) {
                // Remove all state classes including upload-loaded
                zone.classList.remove('has-file', 'uploading', 'error', 'upload-loaded', 'upload-pending', 'upload-success', 'upload-error');
                
                // Reset text color from blue back to default
                const uploadText = zone.querySelector('.upload-text');
                if (uploadText) {
                    uploadText.style.color = '';
                    uploadText.classList.remove('file-info');
                }
            }
            
            // Reset the upload zone to default state
            updateUploadZoneState(fieldName, 'ready', '');
            
            addOutput(`Cleared ${fieldName} file`, 'info');
        }
        
        async function copyReferencedFilesToCurrentSession() {
            console.log('Checking if any files need to be copied to current session...');
            
            if (!window.uploadSession) {
                console.log('No current session - nothing to copy to');
                return;
            }
            
            // Find files that are referenced from other locations (not already in current session)
            const filesToCopy = {};
            const currentSessionPath = `/opt/traxim/input-data/${document.getElementById('userName').value.trim().toLowerCase()}/session_${window.uploadSession}/`;
            
            Object.keys(uploadedFiles).forEach(fieldName => {
                const fileInfo = uploadedFiles[fieldName];
                if (fileInfo && fileInfo.source === 'referenced') {
                    const pathToCheck = fileInfo.filePath || fileInfo.folderPath;
                    if (pathToCheck) {
                        // Only copy if the file is not already in the current session
                        if (!pathToCheck.includes(`session_${window.uploadSession}`)) {
                            filesToCopy[fieldName] = pathToCheck;
                            console.log(`File ${fieldName} needs copying: ${pathToCheck}`);
                        }
                    }
                }
            });
            
            // If there are files to copy, copy them now
            if (Object.keys(filesToCopy).length > 0) {
                try {
                    console.log('Copying referenced files to current session:', filesToCopy);
                    const response = await fetch(`${serverUrl}/api/files/copy-to-session`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            filePaths: filesToCopy,
                            sessionId: window.uploadSession,
                            userName: document.getElementById('userName').value.trim()
                        })
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        // Update uploadedFiles with the new copied paths
                        Object.keys(result.copiedFiles).forEach(fieldName => {
                            if (uploadedFiles[fieldName]) {
                                uploadedFiles[fieldName].filePath = result.copiedFiles[fieldName];
                                uploadedFiles[fieldName].source = 'copied';
                                console.log(`Updated ${fieldName} to use copied file: ${result.copiedFiles[fieldName]}`);
                            }
                        });
                        console.log(`Successfully copied ${Object.keys(result.copiedFiles).length} files to current session`);
                    } else {
                        console.error('Failed to copy files:', result.error);
                        addOutput(`Warning: Could not copy some files to current session: ${result.error}`, 'error');
                    }
                } catch (error) {
                    console.error('Error copying files:', error);
                    addOutput(`Warning: Could not copy files to current session: ${error.message}`, 'error');
                }
            } else {
                console.log('No files need copying - all files are already in current session or uploaded directly');
            }
        }
        
        async function traverseFileTree(item, files) {
            return new Promise((resolve) => {
                if (item.isFile) {
                    item.file((file) => {
                        files.push(file);
                        resolve();
                    });
                } else if (item.isDirectory) {
                    const reader = item.createReader();
                    reader.readEntries(async (entries) => {
                        const promises = entries.map(entry => traverseFileTree(entry, files));
                        await Promise.all(promises);
                        resolve();
                    });
                }
            });
        }
        
        // Update upload path and scenario path (called on every keystroke for real-time feedback)
        function updateUploadPathOnly() {
            const userName = document.getElementById('userName').value.trim();
            if (userName) {
                const userDir = `/opt/traxim/input-data/${userName}/`;
                
                // Update scenario path if it's empty or still at the old default
                const scenarioPath = document.getElementById('scenarioPath').value.trim();
                if (!scenarioPath || scenarioPath === '/opt/traxim/' || scenarioPath.includes('/opt/traxim/input-data/')) {
                    document.getElementById('scenarioPath').value = userDir;
                }
            } else {
                document.getElementById('scenarioPath').value = '';
            }
        }
        
        // Handle username change (called when field loses focus)
        async function handleUsernameChange() {
            const userName = document.getElementById('userName').value.trim();
            // Update scenario path when username changes
            updateScenarioPath();
            if (userName && userName.length >= 2) {
                await validateUserDirectory(userName);
                
                // Refresh dropdowns after username is validated and scenario path is updated
                const scenarioPath = document.getElementById('scenarioPath').value;
                if (scenarioPath && scenarioPath.trim()) {
                    console.log('Username change: Refreshing scenarios dropdown');
                    await refreshScenarios();
                }
                
                console.log('Username change: Refreshing existing scenarios dropdown');
                await refreshExistingScenarios();
            }
        }
        
        // Handle Enter key press in username field
        async function handleUsernameKeypress(event) {
            if (event.key === 'Enter') {
                const userName = document.getElementById('userName').value.trim();
                updateScenarioPath(); // Update scenario path
                if (userName && userName.length >= 2) {
                    await validateUserDirectory(userName);
                    
                    // Refresh dropdowns after username is validated and scenario path is updated
                    const scenarioPath = document.getElementById('scenarioPath').value;
                    if (scenarioPath && scenarioPath.trim()) {
                        console.log('Username Enter key: Refreshing scenarios dropdown');
                        await refreshScenarios();
                    }
                    
                    console.log('Username Enter key: Refreshing existing scenarios dropdown');
                    await refreshExistingScenarios();
                }
            }
        }
        
        // Update upload path and validate directory (legacy function for other calls)
        async function updateUploadPath() {
            updateUploadPathOnly();
            const userName = document.getElementById('userName').value.trim();
            if (userName && userName.length >= 2) {
                await validateUserDirectory(userName);
            }
        }
        
        // Validate username and create directory if needed
        async function validateUserDirectory(userName) {
            if (!userName || userName.length < 2) {
                return;
            }
            
            try {
                const response = await fetch(`${serverUrl}/api/user/validate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userName: userName })
                });
                
                const result = await response.json();
                if (result.success) {
                    // Update username field with normalized version if it changed
                    if (result.normalizedUsername && result.normalizedUsername !== userName) {
                        document.getElementById('userName').value = result.normalizedUsername;
                        addOutput(`Username normalized to: ${result.normalizedUsername} (Linux-compatible)`, 'info');
                        updateUploadPathOnly(); // Update upload path with normalized username
                    }
                    
                    if (result.isNewUser) {
                        addOutput(`Welcome! Created new user directory: ${result.normalizedUsername || userName}`, 'success');
                    } else {
                        addOutput(`Welcome back, ${result.normalizedUsername || userName}!`, 'info');
                    }
                } else {
                    addOutput(`Username validation failed: ${result.error}`, 'error');
                }
            } catch (error) {
                console.log('User validation error (non-critical):', error);
                // Don't show error to user as this is a background validation
            }
        }
        
        // MD5 Hash Implementation
        function md5(string) {
            // Simple MD5 implementation for browser use
            function md5cycle(x, k) {
                var a = x[0], b = x[1], c = x[2], d = x[3];
                a = ff(a, b, c, d, k[0], 7, -680876936);
                d = ff(d, a, b, c, k[1], 12, -389564586);
                c = ff(c, d, a, b, k[2], 17, 606105819);
                b = ff(b, c, d, a, k[3], 22, -1044525330);
                a = ff(a, b, c, d, k[4], 7, -176418897);
                d = ff(d, a, b, c, k[5], 12, 1200080426);
                c = ff(c, d, a, b, k[6], 17, -1473231341);
                b = ff(b, c, d, a, k[7], 22, -45705983);
                a = ff(a, b, c, d, k[8], 7, 1770035416);
                d = ff(d, a, b, c, k[9], 12, -1958414417);
                c = ff(c, d, a, b, k[10], 17, -42063);
                b = ff(b, c, d, a, k[11], 22, -1990404162);
                a = ff(a, b, c, d, k[12], 7, 1804603682);
                d = ff(d, a, b, c, k[13], 12, -40341101);
                c = ff(c, d, a, b, k[14], 17, -1502002290);
                b = ff(b, c, d, a, k[15], 22, 1236535329);
                a = gg(a, b, c, d, k[1], 5, -165796510);
                d = gg(d, a, b, c, k[6], 9, -1069501632);
                c = gg(c, d, a, b, k[11], 14, 643717713);
                b = gg(b, c, d, a, k[0], 20, -373897302);
                a = gg(a, b, c, d, k[5], 5, -701558691);
                d = gg(d, a, b, c, k[10], 9, 38016083);
                c = gg(c, d, a, b, k[15], 14, -660478335);
                b = gg(b, c, d, a, k[4], 20, -405537848);
                a = gg(a, b, c, d, k[9], 5, 568446438);
                d = gg(d, a, b, c, k[14], 9, -1019803690);
                c = gg(c, d, a, b, k[3], 14, -187363961);
                b = gg(b, c, d, a, k[8], 20, 1163531501);
                a = gg(a, b, c, d, k[13], 5, -1444681467);
                d = gg(d, a, b, c, k[2], 9, -51403784);
                c = gg(c, d, a, b, k[7], 14, 1735328473);
                b = gg(b, c, d, a, k[12], 20, -1926607734);
                a = hh(a, b, c, d, k[5], 4, -378558);
                d = hh(d, a, b, c, k[8], 11, -2022574463);
                c = hh(c, d, a, b, k[11], 16, 1839030562);
                b = hh(b, c, d, a, k[14], 23, -35309556);
                a = hh(a, b, c, d, k[1], 4, -1530992060);
                d = hh(d, a, b, c, k[4], 11, 1272893353);
                c = hh(c, d, a, b, k[7], 16, -155497632);
                b = hh(b, c, d, a, k[10], 23, -1094730640);
                a = hh(a, b, c, d, k[13], 4, 681279174);
                d = hh(d, a, b, c, k[0], 11, -358537222);
                c = hh(c, d, a, b, k[3], 16, -722521979);
                b = hh(b, c, d, a, k[6], 23, 76029189);
                a = hh(a, b, c, d, k[9], 4, -640364487);
                d = hh(d, a, b, c, k[12], 11, -421815835);
                c = hh(c, d, a, b, k[15], 16, 530742520);
                b = hh(b, c, d, a, k[2], 23, -995338651);
                a = ii(a, b, c, d, k[0], 6, -198630844);
                d = ii(d, a, b, c, k[7], 10, 1126891415);
                c = ii(c, d, a, b, k[14], 15, -1416354905);
                b = ii(b, c, d, a, k[5], 21, -57434055);
                a = ii(a, b, c, d, k[12], 6, 1700485571);
                d = ii(d, a, b, c, k[3], 10, -1894986606);
                c = ii(c, d, a, b, k[10], 15, -1051523);
                b = ii(b, c, d, a, k[1], 21, -2054922799);
                a = ii(a, b, c, d, k[8], 6, 1873313359);
                d = ii(d, a, b, c, k[15], 10, -30611744);
                c = ii(c, d, a, b, k[6], 15, -1560198380);
                b = ii(b, c, d, a, k[13], 21, 1309151649);
                a = ii(a, b, c, d, k[4], 6, -145523070);
                d = ii(d, a, b, c, k[11], 10, -1120210379);
                c = ii(c, d, a, b, k[2], 15, 718787259);
                b = ii(b, c, d, a, k[9], 21, -343485551);
                x[0] = add32(a, x[0]);
                x[1] = add32(b, x[1]);
                x[2] = add32(c, x[2]);
                x[3] = add32(d, x[3]);
            }
            
            function cmn(q, a, b, x, s, t) {
                a = add32(add32(a, q), add32(x, t));
                return add32((a << s) | (a >>> (32 - s)), b);
            }
            
            function ff(a, b, c, d, x, s, t) {
                return cmn((b & c) | ((~b) & d), a, b, x, s, t);
            }
            
            function gg(a, b, c, d, x, s, t) {
                return cmn((b & d) | (c & (~d)), a, b, x, s, t);
            }
            
            function hh(a, b, c, d, x, s, t) {
                return cmn(b ^ c ^ d, a, b, x, s, t);
            }
            
            function ii(a, b, c, d, x, s, t) {
                return cmn(c ^ (b | (~d)), a, b, x, s, t);
            }
            
            function md51(s) {
                var n = s.length,
                    state = [1732584193, -271733879, -1732584194, 271733878], i;
                for (i = 64; i <= s.length; i += 64) {
                    md5cycle(state, md5blk(s.substring(i - 64, i)));
                }
                s = s.substring(i - 64);
                var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                for (i = 0; i < s.length; i++)
                    tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);
                tail[i >> 2] |= 0x80 << ((i % 4) << 3);
                if (i > 55) {
                    md5cycle(state, tail);
                    for (i = 0; i < 16; i++) tail[i] = 0;
                }
                tail[14] = n * 8;
                md5cycle(state, tail);
                return state;
            }
            
            function md5blk(s) {
                var md5blks = [], i;
                for (i = 0; i < 64; i += 4) {
                    md5blks[i >> 2] = s.charCodeAt(i)
                        + (s.charCodeAt(i + 1) << 8)
                        + (s.charCodeAt(i + 2) << 16)
                        + (s.charCodeAt(i + 3) << 24);
                }
                return md5blks;
            }
            
            function rhex(n) {
                var s = '', j = 0;
                for (; j < 4; j++)
                    s += hex_chr[(n >> (j * 8 + 4)) & 0x0F]
                        + hex_chr[(n >> (j * 8)) & 0x0F];
                return s;
            }
            
            function hex(x) {
                for (var i = 0; i < x.length; i++)
                    x[i] = rhex(x[i]);
                return x.join('');
            }
            
            function add32(a, b) {
                return (a + b) & 0xFFFFFFFF;
            }
            
            var hex_chr = '0123456789ABCDEF'.split('');
            
            return hex(md51(string)).toUpperCase();
        }
        
        // Generate settings hash based on C# GetHashCodeString logic
        function generateSettingsHash() {
            let aggstr = "";
            
            // Note: distanceAlgorithm not available in web interface, skipping
            
            // File paths
            aggstr += document.getElementById('infrastructureFile').value;
            aggstr += document.getElementById('geometryDirectory').value;
            aggstr += document.getElementById('timetable1File').value;
            
            // Note: Commented out in C# code:
            // aggstr += document.getElementById('timetable2File').value;
            // aggstr += document.getElementById('timetableRulesFile').value;
            
            aggstr += document.getElementById('possessionsFile').value;
            aggstr += document.getElementById('speedboardsFile').value;
            aggstr += document.getElementById('tractiveEffortDirectory').value; // TfbDirectory
            
            // Link splitting distance if enabled
            if (document.getElementById('linkSplitting').checked) {
                aggstr += document.getElementById('linkSplittingDistance').value.toString();
            }
            
            // Simulation parameters
            aggstr += document.getElementById('simulationDays').value.toString(); // daysToRun
            aggstr += document.getElementById('windowDays').value.toString(); // daysWindow
            aggstr += document.getElementById('dateQuarter').value.toString(); // quarter
            aggstr += document.getElementById('dateYear').value.toString(); // year
            
            // Note: selectedRegions logic not implemented in web interface yet
            // Would need to add excluded regions functionality
            
            return md5(aggstr);
        }
        
        // Helper function to encode XML entities for safe XML generation
        function encodeXmlEntities(text) {
            if (!text || typeof text !== 'string') {
                return text || '';
            }
            
            return text
                .replace(/&/g, '&amp;')    // & must be first to avoid double-encoding
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }
        
        function gatherScenarioData() {
            console.log('gatherScenarioData() called');
            console.log('Current uploadedFiles:', uploadedFiles);
            console.log('Current upload session:', window.uploadSession);
            // Generate XML content for .scn file
            const now = new Date();
            const dateStr = `${now.getDate()}/${now.getMonth() + 1}/${now.getFullYear()} @ ${now.getHours()}:${now.getMinutes()}`;

            // Helper function to convert absolute paths to relative paths for CommonPath usage
            function makeRelativePath(fullPath) {
                if (!fullPath) return '';
                
                const userName = document.getElementById('userName').value.trim().toLowerCase();
                const userDir = `/opt/traxim/input-data/${userName}/`;
                
                // If path starts with user directory, make it relative
                if (fullPath.startsWith(userDir)) {
                    return fullPath.substring(userDir.length);
                }
                
                // If it's already relative or doesn't start with user dir, return as-is
                return fullPath;
            }

            // Helper function to get file path from uploaded files tracking
            function getUploadedFilePath(fieldName) {
                // Determine the correct input element ID based on field type
                let inputElement;
                if (fieldName === 'geometry') {
                    inputElement = document.getElementById('geometryDirectory');
                } else if (fieldName === 'tractiveEffort') {
                    inputElement = document.getElementById('tractiveEffortDirectory');
                } else {
                    inputElement = document.getElementById(fieldName + 'File');
                }
                
                console.log(`getUploadedFilePath(${fieldName}):`, {
                    uploadedFiles: uploadedFiles[fieldName],
                    inputValue: inputElement ? inputElement.value : 'no element'
                });
                
                // Check if there's an uploaded file/folder in our tracking system
                if (uploadedFiles[fieldName]) {
                    // For folder uploads (geometry, tractiveEffort), use folderPath
                    if (uploadedFiles[fieldName].folderPath) {
                        console.log(`Using uploaded folder path for ${fieldName}:`, uploadedFiles[fieldName].folderPath);
                        return uploadedFiles[fieldName].folderPath;
                    }
                    // For file uploads, use filePath
                    else if (uploadedFiles[fieldName].filePath) {
                        console.log(`Using uploaded file path for ${fieldName}:`, uploadedFiles[fieldName].filePath);
                        return uploadedFiles[fieldName].filePath;
                    }
                }
                
                // Fallback to input value (for backwards compatibility)
                if (inputElement && inputElement.value) {
                    console.log(`Using input value for ${fieldName}:`, inputElement.value);
                    return inputElement.value;
                }
                
                console.log(`No file path found for ${fieldName}`);
                return '';
            }

            // Set CommonPath to user directory and make all file paths relative
            const userName = document.getElementById('userName').value.trim().toLowerCase();
            const commonPath = `/opt/traxim/input-data/${userName}/`;

            const xmlContent = `<?xml version="1.0" encoding="utf-8"?>
<Traxim Version="5.0.0.0" SettingsVersion="3" WrittenAt="${dateStr}">
  <!--TraximWeb by Derek Harris, James Moor, Stuart Mau.-->
  <SimSettings>
    <CommonPath>${encodeXmlEntities(commonPath)}</CommonPath>
    <Infrastructure>${encodeXmlEntities(makeRelativePath(getUploadedFilePath('infrastructure')))}</Infrastructure>
    <GeometryDirectory>${encodeXmlEntities(makeRelativePath(getUploadedFilePath('geometry')))}</GeometryDirectory>
    <Timetable>${encodeXmlEntities(makeRelativePath(getUploadedFilePath('timetable1')))}</Timetable>
    <Timetable2>${encodeXmlEntities(makeRelativePath(getUploadedFilePath('timetable2')))}</Timetable2>
    <TimetableRules>${encodeXmlEntities(makeRelativePath(getUploadedFilePath('timetableRules')))}</TimetableRules>
    <Possessions>${encodeXmlEntities(makeRelativePath(getUploadedFilePath('possessions')))}</Possessions>
    <Speedboards>${encodeXmlEntities(makeRelativePath(getUploadedFilePath('speedboards')))}</Speedboards>
    <TBcurvesDirectory>${encodeXmlEntities(makeRelativePath(getUploadedFilePath('tractiveEffort')))}</TBcurvesDirectory>
    <Regions>${encodeXmlEntities(makeRelativePath(getUploadedFilePath('regions')))}</Regions>
    <OutputDirectory>${encodeXmlEntities(makeRelativePath(getScenarioOutputsPath()))}</OutputDirectory>
    <LiveLocations>${encodeXmlEntities(makeRelativePath(getUploadedFilePath('liveLocations')))}</LiveLocations>
    <Perturbations>${encodeXmlEntities(document.getElementById('perturbations').value)}</Perturbations>
    <Seed>${encodeXmlEntities(document.getElementById('initialSeed').value)}</Seed>
    <DaysToRun>${encodeXmlEntities(document.getElementById('simulationDays').value)}</DaysToRun>
    <WindowDays>${encodeXmlEntities(document.getElementById('windowDays').value)}</WindowDays>
    <EndQuarter>${encodeXmlEntities(document.getElementById('dateQuarter').value)}</EndQuarter>
    <EndYear>${encodeXmlEntities(document.getElementById('dateYear').value)}</EndYear>
    <LinkSplit Enabled="${document.getElementById('linkSplitting').checked ? 'True' : 'False'}">${encodeXmlEntities(document.getElementById('linkSplittingDistance').value)}</LinkSplit>
    <AutoCurveSpeedLimiting Enabled="${document.getElementById('autoCurveSpeedLimiting').checked ? 'True' : 'False'}"></AutoCurveSpeedLimiting>
    <TimetableWrapping Enabled="${document.getElementById('wrapping').checked ? 'True' : 'False'}"></TimetableWrapping>
    <LiveMode Enabled="${document.getElementById('liveMode').checked ? 'True' : 'False'}"></LiveMode>
    <WriteHotStartTimesCSV Enabled="${document.getElementById('writeHotStartTimesCSV').checked ? 'True' : 'False'}"></WriteHotStartTimesCSV>
    <SettingsHash>${generateSettingsHash()}</SettingsHash>
  </SimSettings>
</Traxim>`;            
            console.log('gatherScenarioData() completed, XML length:', xmlContent.length);
            return xmlContent;
        }
        
        // Helper function to verify uploaded files exist on server
        async function verifyFilesExist() {
            console.log('=== FILE VERIFICATION DEBUG ===');
            const fileFields = ['infrastructure', 'timetable1', 'timetable2', 'timetableRules', 'possessions', 'speedboards', 'regions'];
            
            console.log('Upload session:', window.uploadSession);
            console.log('All uploaded files:', uploadedFiles);
            
            for (const field of fileFields) {
                const filePath = getUploadedFilePath(field);
                console.log(`${field}:`, {
                    filePath: filePath,
                    uploadedFileData: uploadedFiles[field],
                    hasFile: !!filePath
                });
                
                if (filePath) {
                    addOutput(`File path for ${field}: ${filePath}`, 'info');
                }
            }
            console.log('=== END FILE VERIFICATION ===');
        }
        
        // Helper function to get the outputs path for the current scenario
        function getScenarioOutputsPath() {
            const userName = document.getElementById('userName').value.trim().toLowerCase();
            const sessionId = window.uploadSession || 'default';
            
            // For new scenarios being created with uploads, use session path within user directory
            if (sessionId !== 'default') {
                return `/opt/traxim/input-data/${userName}/session_${sessionId}/outputs/`;
            }
            
            // For existing scenarios or scenarios being saved, determine where input files are located
            // The .scn file is saved to scenarioPath (central), but outputs go with the input files
            const selectedScenario = document.getElementById('existingScenarios').value || 
                                    document.getElementById('scenarioFile').value;
                                    
            if (selectedScenario) {
                // For existing scenario being loaded/modified
                const scenarioName = selectedScenario.replace('.scn', '');
                return `/opt/traxim/input-data/${userName}/${scenarioName}/outputs/`;
            } else {
                // For new scenario being created (but not from uploads)
                // Use a generic outputs folder in user directory
                return `/opt/traxim/input-data/${userName}/outputs/`;
            }
        }

        // Helper function to ensure outputs directory exists
        async function ensureOutputsDirectoryExists() {
            const outputsPath = getScenarioOutputsPath();
            
            console.log('=== OUTPUTS DIRECTORY CREATION DEBUG ===');
            console.log('Session ID:', window.uploadSession);
            console.log('Generated outputs path:', outputsPath);
            console.log('=== END OUTPUTS DEBUG ===');
            
            try {
                const response = await fetch(`${serverUrl}/api/mkdir`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: outputsPath })
                });
                
                const result = await response.json();
                if (result.success) {
                    addOutput(`Created outputs directory: ${outputsPath}`, 'info');
                    return true;
                } else {
                    addOutput(`Failed to create outputs directory: ${result.error}`, 'error');
                    return false;
                }
            } catch (error) {
                addOutput(`Error creating outputs directory: ${error.message}`, 'error');
                return false;
            }
        }
        
        async function populateScenarioData(data) {
            try {
                console.log('populateScenarioData received:', typeof data, data);
                
                // Check if data is XML (string starting with <?xml) or JSON (object)
                if (typeof data === 'string' && data.trim().startsWith('<?xml')) {
                    // Handle XML (.scn) format
                    await populateFromXml(data);
                } else if (typeof data === 'string') {
                    // Try to parse as JSON string first, then as plain XML
                    try {
                        const parsedData = JSON.parse(data);
                        await populateFromJson(parsedData);
                    } catch (jsonError) {
                        // If JSON parsing fails, try as XML
                        await populateFromXml(data);
                    }
                } else if (typeof data === 'object') {
                    // Handle JSON format (for backward compatibility)
                    await populateFromJson(data);
                } else {
                    throw new Error('Unsupported data format');
                }
            } catch (error) {
                addOutput(`Error loading scenario: ${error.message}`, 'error');
                console.error('Data loading error:', error);
            }
        }
        
        async function populateFromXml(xmlContent) {
            try {
                console.log('populateFromXml received content:', typeof xmlContent, xmlContent.substring(0, 200) + '...');
                
                // Clear current session when loading an existing scenario
                // First upload after loading will create a new session
                window.uploadSession = null;
                console.log('Cleared upload session - first upload will create new session');
                
                // Clean up common XML entity issues before parsing
                let cleanXmlContent = xmlContent;
                // Replace unescaped ampersands with proper XML entities
                cleanXmlContent = cleanXmlContent.replace(/&(?![a-zA-Z0-9#]+;)/g, '&amp;');
                
                // Parse XML content
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(cleanXmlContent, 'text/xml');
                
                // Check for parsing errors
                const parserError = xmlDoc.querySelector('parsererror');
                if (parserError) {
                    console.error('XML parsing error:', parserError.textContent);
                    console.error('Original XML content:', xmlContent.substring(0, 500));
                    console.error('Cleaned XML content:', cleanXmlContent.substring(0, 500));
                    throw new Error(`Invalid XML format: ${parserError.textContent}`);
                }
                
                // Helper function to get text content safely
                const getElementText = (tagName) => {
                    const element = xmlDoc.querySelector(tagName);
                    return element ? element.textContent.trim() : '';
                };
                
                // Helper function to get boolean attribute safely
                const getBooleanAttribute = (tagName, attrName = 'Enabled') => {
                    const element = xmlDoc.querySelector(tagName);
                    if (element && element.hasAttribute(attrName)) {
                        return element.getAttribute(attrName).toLowerCase() === 'true';
                    }
                    return false;
                };
                
                // Note: Cannot set .value on file input elements due to browser security
                // Instead, update the upload zone displays to show what files are referenced
                const filePaths = {
                    infrastructure: getElementText('Infrastructure'),
                    geometry: getElementText('GeometryDirectory'),
                    timetable1: getElementText('Timetable'),
                    timetable2: getElementText('Timetable2'),
                    timetableRules: getElementText('TimetableRules'),
                    possessions: getElementText('Possessions'),
                    speedboards: getElementText('Speedboards'),
                    tractiveEffort: getElementText('TBcurvesDirectory'),
                    regions: getElementText('Regions'),
                    liveLocations: getElementText('LiveLocations')
                };
                
                console.log('Loaded file paths from scenario:', filePaths);
                
                // Update upload zones to show loaded file references (with file copying)
                await updateUploadZonesFromLoadedScenario(filePaths);
                
                // Update outputs folder based on scenario file paths
                updateOutputsFolderFromScenario(xmlDoc);
                
                // Populate simulation parameters
                const perturbationsValue = getElementText('Perturbations') || '1';
                console.log('[SCENARIO LOAD] Perturbations from XML:', perturbationsValue);
                document.getElementById('perturbations').value = perturbationsValue;
                console.log('[SCENARIO LOAD] Set perturbations field to:', document.getElementById('perturbations').value);
                document.getElementById('initialSeed').value = getElementText('Seed') || '0';
                document.getElementById('simulationDays').value = getElementText('DaysToRun') || '10';
                document.getElementById('windowDays').value = getElementText('WindowDays') || '7';
                document.getElementById('dateQuarter').value = getElementText('EndQuarter') || '3';
                document.getElementById('dateYear').value = getElementText('EndYear') || '2025';
                
                // Populate boolean settings with their values
                document.getElementById('linkSplitting').checked = getBooleanAttribute('LinkSplit');
                document.getElementById('linkSplittingDistance').value = getElementText('LinkSplit') || '3.0';
                document.getElementById('autoCurveSpeedLimiting').checked = getBooleanAttribute('AutoCurveSpeedLimiting');
                document.getElementById('wrapping').checked = getBooleanAttribute('TimetableWrapping');
                document.getElementById('liveMode').checked = getBooleanAttribute('LiveMode');
                document.getElementById('writeHotStartTimesCSV').checked = getBooleanAttribute('WriteHotStartTimesCSV');
                
                addOutput('Scenario loaded successfully', 'info');
            } catch (error) {
                addOutput(`Error parsing scenario file: ${error.message}`, 'error');
                console.error('XML parsing error:', error);
            }
        }
        
        async function populateFromJson(data) {
            console.log('populateFromJson received data keys:', Object.keys(data));
            
            // Helper function to get value with multiple possible property names
            const getValue = (data, ...keys) => {
                for (const key of keys) {
                    if (data[key] !== undefined && data[key] !== null) {
                        return data[key];
                    }
                }
                return '';
            };
            
            // Note: Cannot set .value on file input elements due to browser security
            // Instead, update the upload zone displays to show what files are referenced
            const filePaths = {
                infrastructure: getValue(data, 'infrastructure', 'Infrastructure'),
                geometry: getValue(data, 'geometryDirectory', 'GeometryDirectory'),
                timetable1: getValue(data, 'timetable1', 'Timetable'),
                timetable2: getValue(data, 'timetable2', 'Timetable2'),
                timetableRules: getValue(data, 'timetableRules', 'TimetableRules'),
                possessions: getValue(data, 'possessions', 'Possessions'),
                speedboards: getValue(data, 'speedboards', 'Speedboards'),
                tractiveEffort: getValue(data, 'tractiveEffortDirectory', 'TBcurvesDirectory'),
                regions: getValue(data, 'regions', 'Regions'),
                liveLocations: getValue(data, 'liveLocations', 'LiveLocations')
            };
            
            console.log('Loaded file paths from JSON scenario:', filePaths);
            
            // Update upload zones to show loaded file references (with file copying)
            await updateUploadZonesFromLoadedScenario(filePaths);
            
            // Update outputs folder based on scenario data
            updateOutputsFolderFromScenarioData(data);
            // outputDirectory is now calculated from scenario folder + 'outputs' subfolder
            
            // Handle simulation parameters with multiple naming conventions
            document.getElementById('dateYear').value = getValue(data, 'dateYear', 'EndYear') || 2025;
            document.getElementById('dateQuarter').value = getValue(data, 'dateQuarter', 'EndQuarter') || 1;
            document.getElementById('windowDays').value = getValue(data, 'windowDays', 'WindowDays') || 7;
            document.getElementById('simulationDays').value = getValue(data, 'simulationDays', 'DaysToRun') || 1;
            document.getElementById('initialSeed').value = getValue(data, 'initialSeed', 'Seed') || 12345;
            document.getElementById('perturbations').value = getValue(data, 'perturbations', 'Perturbations') || 100;
            
            // Handle link splitting with distance
            const linkSplitValue = getValue(data, 'linkSplittingDistance', 'LinkSplit');
            if (linkSplitValue) {
                document.getElementById('linkSplittingDistance').value = linkSplitValue;
                document.getElementById('linkSplitting').checked = true;
            } else {
                document.getElementById('linkSplitting').checked = getValue(data, 'linkSplitting') !== false;
            }
            
            // Handle boolean settings
            document.getElementById('autoCurveSpeedLimiting').checked = getValue(data, 'autoCurveSpeedLimiting', 'AutoCurveSpeedLimiting') !== false;
            document.getElementById('wrapping').checked = getValue(data, 'wrapping', 'TimetableWrapping') === true;
            document.getElementById('liveMode').checked = getValue(data, 'liveMode', 'LiveMode') === true;
            
            addOutput('Scenario loaded successfully (JSON format)', 'info');
        }
        
        async function createNewScenario() {
            const name = document.getElementById('newScenarioName').value;
            const userName = document.getElementById('userName').value.trim();
            
            if (!name) {
                addOutput('Please enter a scenario name', 'error');
                return;
            }
            
            if (!userName) {
                addOutput('Please enter your username', 'error');
                return;
            }
            
            console.log('Starting createNewScenario for:', name);
            
            // Try to create outputs directory (non-blocking)
            ensureOutputsDirectoryExists().catch(err => {
                console.warn('Could not create outputs directory:', err);
            });
            
            console.log('Gathering scenario data...');
            const scenarioData = gatherScenarioData();
            console.log('Scenario data length:', scenarioData ? scenarioData.length : 'null');
            
            // Debug: Check if files actually exist on server before submission
            await verifyFilesExist();
            
            const scenarioPath = document.getElementById('scenarioPath').value;
            const workingMode = document.getElementById('workingMode').value;
            console.log('scenarioPath:', scenarioPath, 'workingMode:', workingMode);

            
            try {
                console.log('Sending scenario to server:', { name, userName, scenarioPath });
                const response = await fetch(`${serverUrl}/api/scenario/create`, {
                    method: 'POST',
                    body: JSON.stringify({ 
                        name, 
                        data: scenarioData, 
                        userName,
                        scenarioPath,

                        localPath
                    })
                });
                console.log('Server response status:', response.status, response.ok);
                
                const result = await response.json();
                console.log('Server response result:', result);
                
                if (result.success) {
                    addOutput(`Created new scenario: ${result.finalName}`, 'info');
                    console.log('Scenario created successfully, refreshing dropdowns...');

                    refreshScenarios();
                    refreshExistingScenarios();
                    document.getElementById('newScenarioName').value = '';
                } else {
                    console.error('Scenario creation failed:', result.error);
                    addOutput(`Failed to create scenario: ${result.error}`, 'error');
                }
            } catch (error) {
                console.error('Scenario creation error:', error);
                addOutput(`Scenario creation error: ${error.message}`, 'error');
            }
        }
        
        async function saveCurrentScenario() {
            const selectedScenario = document.getElementById('existingScenarios').value;
            const userName = document.getElementById('userName').value.trim();
            
            if (!selectedScenario) {
                addOutput('Please select a scenario from the dropdown first', 'error');
                return;
            }
            
            if (!userName) {
                addOutput('Please enter your username', 'error');
                return;
            }
            
            // Try to create outputs directory (non-blocking)
            ensureOutputsDirectoryExists().catch(err => {
                console.warn('Could not create outputs directory:', err);
            });
            
            const scenarioData = gatherScenarioData();
            const scenarioPath = document.getElementById('scenarioPath').value;
            
            try {
                const response = await fetch(`${serverUrl}/api/scenario/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        name: selectedScenario, 
                        data: scenarioData, 
                        userName,
                        scenarioPath
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    addOutput(`Saved scenario: ${selectedScenario}`, 'info');
                } else {
                    addOutput(`Failed to save scenario: ${result.error}`, 'error');
                }
            } catch (error) {
                addOutput(`Scenario save error: ${error.message}`, 'error');
            }
        }
        
        async function saveScenarioAs() {
            const userName = document.getElementById('userName').value.trim();
            
            if (!userName) {
                addOutput('Please enter your username', 'error');
                return;
            }
            
            // Create intelligent default name
            let defaultName = 'New_Scenario.scn';
            
            // Show file dialog to get the new scenario name
            const newName = window.prompt(
                'Save Scenario As\n\nEnter a name for the new scenario file:', 
                defaultName
            );
            
            // User cancelled the dialog
            if (newName === null) {
                addOutput('Save as cancelled', 'info');
                return;
            }
            
            // User entered empty name
            if (!newName.trim()) {
                addOutput('Please enter a valid scenario name', 'error');
                return;
            }
            
            let finalName = newName.trim();
            
            // Use filename as provided (no username prefix needed since files are in user directory)
            let nameForServer = finalName;
            
            addOutput(`Saving scenario as: ${finalName}`, 'info');
            
            // Ensure session exists for Save As (create one if needed for setting changes)
            await ensureSessionExists();
            
            addOutput(`Using session: ${window.uploadSession}`, 'info');
            
            // Copy any referenced files from loaded scenario to current session
            try {
                await copyReferencedFilesToCurrentSession();
            } catch (error) {
                console.error('Error copying referenced files:', error);
                addOutput(`Warning: Could not copy some referenced files: ${error.message}`, 'warning');
                // Continue with saving even if file copying fails
            }
            
            const scenarioData = gatherScenarioData();
            const scenarioPath = document.getElementById('scenarioPath').value;
            
            try {
                const response = await fetch(`${serverUrl}/api/scenario/create`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        name: nameForServer, 
                        data: scenarioData, 
                        userName,
                        scenarioPath
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    addOutput(`Saved scenario as: ${result.finalName}`, 'success');
                    refreshScenarios();
                    refreshExistingScenarios();
                    
                    // Select the new scenario in the dropdown
                    setTimeout(() => {
                        document.getElementById('existingScenarios').value = result.finalName;
                    }, 500);
                    
                    // DON'T reset session after save - keep it so next modification can reference these files
                    // The session will be automatically replaced when user makes changes
                    addOutput('Scenario saved - modifications will create a new session', 'info');
                    
                    // Reset upload zones to ready state (keeping form values visible)
                    resetUploadZonesAfterSave();
                } else {
                    addOutput(`Failed to save scenario as: ${result.error}`, 'error');
                }
            } catch (error) {
                addOutput(`Save as error: ${error.message}`, 'error');
            }
        }
        
        function resetUploadZonesAfterSave() {
            // Reset all upload zones to blue "ready" state while keeping the saved file names visible
            const allFields = ['infrastructure', 'geometry', 'timetable1', 'timetable2', 'timetableRules', 'possessions', 'speedboards', 'tractiveEffort', 'regions', 'liveLocations'];
            
            allFields.forEach(fieldName => {
                const zone = document.querySelector(`[data-field="${fieldName}"]`);
                if (zone && uploadedFiles[fieldName]) {
                    // Remove upload state classes but keep the file info
                    zone.classList.remove('upload-pending', 'upload-success', 'upload-error', 'upload-loaded');
                    // Set to ready state (blue) to indicate files are saved
                    zone.classList.add('upload-ready');
                    
                    const uploadText = zone.querySelector('.upload-text');
                    if (uploadText && uploadedFiles[fieldName]) {
                        // Keep showing the saved file names
                        const fileInfo = uploadedFiles[fieldName];
                        if (fileInfo.type === 'folder') {
                            uploadText.innerHTML = `üìÅ ${fileInfo.fileName}`;
                        } else {
                            uploadText.innerHTML = `üìÑ ${fileInfo.fileName}`;
                        }
                        uploadText.style.color = '#2196F3'; // Blue color to indicate saved files
                    }
                } else if (zone) {
                    // If no file was uploaded for this field, reset to empty state
                    zone.classList.remove('upload-pending', 'upload-success', 'upload-error', 'upload-loaded', 'upload-ready');
                    
                    const uploadText = zone.querySelector('.upload-text');
                    if (uploadText) {
                        const isFolderField = ['geometry', 'tractiveEffort'].includes(fieldName);
                        uploadText.textContent = isFolderField ? 'Drag & drop folder here or click to browse' : 'Drag & drop files here or click to browse';
                    }
                }
                
                // Clear file inputs (but keep the visual file names from uploadedFiles)
                const fileInput = document.getElementById(fieldName + 'File');
                if (fileInput) {
                    fileInput.value = '';
                }
                
                const dirInput = document.getElementById(fieldName + 'Directory');
                if (dirInput) {
                    dirInput.value = '';
                }
            });
            
            // Keep uploadedFiles for display purposes but mark session as reset
            // uploadedFiles = {}; // Don't clear this - we need it to show saved file names
            
            console.log('Upload zones reset after save - ready for new modifications');
        }
        
        async function loadScenario() {
            const scenarioFile = document.getElementById('scenarioFile').value;
            console.log('[LOAD SCENARIO] Starting loadScenario for:', scenarioFile);
            if (!scenarioFile) {
                addOutput('Please select a scenario file first', 'error');
                return;
            }
            
            const scenarioPath = document.getElementById('scenarioPath').value;
            const userName = document.getElementById('userName').value.trim();
            
            try {
                console.log('[LOAD SCENARIO] Fetching scenario from server...');
                const response = await fetch(`${serverUrl}/api/scenario/load`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        name: scenarioFile, 
                        userName: userName,
                        scenarioPath 
                    })
                });
                
                console.log('[LOAD SCENARIO] Response received, status:', response.status);
                const result = await response.json();
                console.log('[LOAD SCENARIO] Result success:', result.success);
                if (result.success) {
                    console.log('[LOAD SCENARIO] Populating scenario data...');
                    await populateScenarioData(result.data);
                    // Update currentSessionId to match the loaded scenario
                    window.currentSessionId = scenarioFile.replace('.scn', '');
                    console.log('[SESSION] Updated currentSessionId to:', window.currentSessionId);
                    console.log('[LOAD SCENARIO] Completed successfully');
                    addOutput(`Loaded scenario: ${scenarioFile}`, 'info');
                } else {
                    console.log('[LOAD SCENARIO] Failed:', result.error);
                    addOutput(`Failed to load scenario: ${result.error}`, 'error');
                }
            } catch (error) {
                console.error('[LOAD SCENARIO] Error:', error);
                addOutput(`Scenario load error: ${error.message}`, 'error');
            }
        }

        // Username is set from authenticated session in checkAuthentication()
        // No need to load/save from localStorage as it would override the authenticated user
        
        // Logout handler
        async function handleLogout() {
            const confirmed = await showCustomConfirm('Logout', 'Are you sure you want to logout?');
            if (!confirmed) {
                return;
            }
            
            try {
                await fetch(`${serverUrl}/api/auth/logout`, {
                    method: 'POST',
                    credentials: 'include'
                });
                
                // Clear local storage (especially any cached usernames)
                localStorage.clear();
                
                // Redirect to login
                window.location.href = '/login.html';
            } catch (error) {
                console.error('Logout error:', error);
                // Still redirect even on error
                window.location.href = '/login.html';
            }
        }

        // Save settings when inputs change
        document.getElementById('executablePath').addEventListener('blur', saveSettings);
        document.getElementById('scenarioPath').addEventListener('blur', saveSettings);
        document.getElementById('updateInterval').addEventListener('change', saveSettings);
        
        // Username is set from authentication and should not be manually changed

        // ========================================
        // PRICING AND BILLING FUNCTIONS
        // ========================================
        
        // Store validation result with conflict count
        async function storeValidationResult(sessionId, scenarioName, conflictCount, success) {
            try {
                const response = await fetch(`${serverUrl}/api/pricing/validation-result`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        sessionId: sessionId,
                        scenarioName: scenarioName,
                        conflictCount: conflictCount,
                        success: success
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    console.log(`Validation result stored: ${conflictCount} conflicts`);
                }
            } catch (error) {
                console.error('Error storing validation result:', error);
            }
        }
        
        // Show pricing confirmation dialog before running simulation
        async function showPricingDialog(sessionId, perturbations, scenarioName = 'Unknown') {
            try {
                // Log perturbations value for debugging
                console.log(`[PRICING DIALOG] SessionId: ${sessionId}, Perturbations: ${perturbations} (type: ${typeof perturbations}), Scenario: ${scenarioName}`);
                
                // First check if user has valid seat
                const seatResponse = await fetch(`${serverUrl}/api/pricing/check-seat`, {
                    method: 'GET',
                    credentials: 'include'
                });
                
                const seatCheck = await seatResponse.json();
                
                // In beta mode, hasValidSeat is always true from backend
                if (!seatCheck.hasValidSeat) {
                    await showCustomAlert('Subscription Expired', 'Your subscription has expired. Please renew to continue using Traxim.');
                    return false;
                }
                
                // Calculate price
                const priceResponse = await fetch(`${serverUrl}/api/pricing/calculate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        sessionId: sessionId,
                        perturbations: perturbations
                    })
                });
                
                const pricing = await priceResponse.json();
                
                if (!pricing.success) {
                    if (pricing.needsValidation) {
                        await showCustomAlert('Validation Required', 'This scenario has not been successfully validated.\n\nPlease validate the scenario first before resolving conflicts.');
                        return false;
                    }
                    throw new Error(pricing.error);
                }
                
                // Build pricing message
                const isBatch = pricing.isBatch;
                let message = `Scenario: ${scenarioName}\n\n`;
                message += `Conflicts detected: ${pricing.conflictCount}\n`;
                message += `Perturbations: ${perturbations}\n`;
                message += `Unit price: ‚Ç¨${pricing.unitPrice} per conflict\n`;
                message += `Base price: ‚Ç¨${pricing.basePrice}\n`;
                
                if (isBatch) {
                    message += `Batch simulation (multiple perturbations):\n  ${pricing.batchMultiplier}x multiplier\n`;
                }
                
                message += `\nTotal cost: ‚Ç¨${pricing.totalPrice}\n`;
                
                if (pricing.betaMode) {
                    message += `\n‚ö†Ô∏è BETA MODE:\nThis charge is advisory only.\nAll simulations are currently free\nduring beta testing.\n`;
                }
                
                message += `\nDo you want to proceed with this simulation?`;
                
                // Show confirmation dialog
                const confirmed = await showCustomConfirm('Simulation Pricing', message);
                
                if (confirmed && !pricing.betaMode) {
                    // Record the cost (will be billed monthly)
                    // In production, this would trigger Stripe billing
                    await recordSimulationCost(sessionId, pricing);
                }
                
                return confirmed;
                
            } catch (error) {
                console.error('Error in pricing dialog:', error);
                addOutput(`Pricing error: ${error.message}`, 'error');
                return false;
            }
        }
        
        // Record simulation cost for billing
        async function recordSimulationCost(sessionId, pricing) {
            try {
                const scenarioFile = document.getElementById('scenarioFile').value;
                const perturbations = parseInt(document.getElementById('perturbations').value) || 1;
                
                await fetch(`${serverUrl}/api/pricing/record-cost`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        sessionId: sessionId,
                        scenarioName: scenarioFile,
                        perturbations: perturbations
                    })
                });
            } catch (error) {
                console.error('Error recording cost:', error);
            }
        }

    </script>
    
    <!-- File Picker Modal -->
    <div id="filePickerModal" class="file-picker-modal">
        <div class="file-picker-content">
            <div class="file-picker-header">
                <div class="file-picker-title">Select File</div>
                <button class="file-picker-close" onclick="closeFilePicker()">&times;</button>
            </div>
            <div class="file-picker-body">
                <ul id="fileList" class="file-list">
                    <!-- Files will be populated here -->
                </ul>
                <div id="emptyState" class="empty-state" style="display: none;">
                    <div>üìÅ</div>
                    <p>No CSV files found in your directory.</p>
                    <p>Upload some files first to see them here.</p>
                </div>
            </div>
            <div class="file-picker-footer">
                <button id="selectFileBtn" class="file-picker-btn primary" onclick="selectFile()" disabled>Select</button>
            </div>
        </div>
    </div>

    <!-- Download Picker Modal -->
    <div id="downloadPickerModal" class="file-picker-modal">
        <div class="file-picker-content">
            <div class="file-picker-header">
                <div class="file-picker-title">Download Files</div>
                <button class="file-picker-close" onclick="closeDownloadPicker()">&times;</button>
            </div>
            <div class="file-picker-body">
                <ul id="downloadFileList" class="file-list">
                    <!-- Files will be populated here -->
                </ul>
                <div id="downloadEmptyState" class="empty-state" style="display: none;">
                    <div>üìÅ</div>
                    <p>No files found in this directory.</p>
                    <p>Run a simulation first to generate output files.</p>
                </div>
            </div>
            <div class="file-picker-footer">
                <button id="downloadSelectedBtn" class="file-picker-btn primary" onclick="downloadSelectedFiles()" disabled>Download Selected</button>
            </div>
        </div>
    </div>
</body>
</html>